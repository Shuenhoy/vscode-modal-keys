<!DOCTYPE html><html><head><title>Modal Keys Documentation</title><meta charset="utf-8"><link rel="stylesheet" href="https://haberdashpi.github.io/vscode-modal-keys/doc_index.1589cea6.css"></head><body> <script src="https://haberdashpi.github.io/vscode-modal-keys/doc_index.7ada6e43.js"></script> <div class="content"> <h1 id="heading-#getting-started"><a class="header-anchor" id="getting-started" href="#getting-started"> </a>Getting Started</h1> <p>Here, it is assumed you understand the conventions of Vim: if you are new to what normal mode is, and how modal editors work, <a href="https://haberdashpi.github.io/vscode-modal-keys/tutorial.html">read the tutorial</a>. If you are familiar with vim, but want to get started without reading the docs, you can <a href="https://haberdashpi.github.io/vscode-modal-keys/preset_index.html">use a preset</a></p> <p>ModalKeys has two built in modes, and as many custom modes as you want. By default, VSCode will open in normal mode. (<a href="#start-in-normal-mode">This can be changed</a>)</p> <p>To define the key mappings for these modes, you should create a javascript file (e.g. <code>mybindings.js</code>). When run, the file should evaluate to an object with the single property <code>keybindings</code>; this should define all of your bindings. If your bindings are simple enough you can also use a <code>json</code> or <code>jsonc</code> file (but this will limit the flexibility of your bindings).</p> <p>There are three parts to the documentation</p> <h2 id="heading-#minimal-configuration"><a class="header-anchor" id="minimal-configuration" href="#minimal-configuration"> </a>Minimal configuration</h2> <p>Your keybindings should include at least one binding that will switch the editor to the <em>insert mode</em>, which is the same as VS Code's default mode.</p> <pre><code class="language-js"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = {keybindings: {
    i: <span class="hljs-string">&quot;modalkeys.enterInsert&quot;</span>
}}
</code></pre> <p>By default, a binding works for all modes except insert mode. Mode specific bindings are <a href="#custom-modes">documented below</a>.</p> <p>Bindings can then be set by running the command <code>&quot;ModalKeys: Import preset keybindings&quot;</code> on this file.</p> <p>The simplest type of binding maps a series of keystrokes to a given VSCode command. You can find these commands by looking at the list of keybindings (e.g. <key>Ctrl/Cmd</key>-<key>K</key> <key>Ctrl/Cmd</key>+<key>S</key> on windows) and copying the command ID from the right-click menu. More advanced keybindings are covered below.</p> <p>ModalKeys adds a regular VS Code keyboard shortcut for <key>Esc</key> to return back to normal mode. If you wish, you can remap this command to another key by pressing <key>Ctrl/Cmd</key>+<key>K</key> <key>Ctrl/Cmd</key>+<key>S</key>.</p> <h2 id="heading-#visual-mode"><a class="header-anchor" id="visual-mode" href="#visual-mode"> </a>Visual mode</h2> <p>Visual mode works a bit differently than Vim's. Any time we are in normal mode (e.g. hit 'escape') and text happens to be selected, visual mode starts. Visual mode can also be manually started.</p> <p>ModalKeys defines a new command, <code>modalkeys.toggleSelection</code>, which allows you to start selecting text in normal mode without holding down the shift key.</p> <p>You can change the text shown in status bar during visual mode using <a href="#changing-status-bar">configuration parameters</a>.</p> <p>To define a binding specific to visual mode just place <code>visual::</code> in front of the binding sequence.</p> <h2 id="heading-#custom-modes"><a class="header-anchor" id="custom-modes" href="#custom-modes"> </a>Custom Modes</h2> <p>To define custom modes, just define keybindings for that mode. Custom modes behave like normal mode in all respects except that they have their own set of keymappings. To define bindings specific to one or more modes, you prefix the bindings with <code>[modename]::</code>. You can specificy multiple modes using <code>|</code> e.g. <code>mycustommode|visual::</code>.</p> <p>To enter the given mode, you will need to call the command <code>modalkeys.enterMode</code> with the argument <code>mode</code> set to the name of the custom mode.</p> <p>For example, the following would map the typical directional keys of vim to a delete command when you are in &quot;evil&quot; mode.</p> <pre><code class="language-js"><span class="hljs-string">&quot;modalkeys.keybinding&quot;</span>: {
    <span class="hljs-string">&quot;D&quot;</span>: { <span class="hljs-keyword">command</span>: <span class="hljs-string">&quot;modalkeys.enterMode&quot;</span>, <span class="hljs-keyword">args</span>: { <span class="hljs-keyword">mode</span>: <span class="hljs-string">&quot;evil&quot;</span> } },
    <span class="hljs-string">&quot;evil::D&quot;</span>: { <span class="hljs-keyword">command</span>: <span class="hljs-string">&quot;modalkeys.enterMode&quot;</span>, <span class="hljs-keyword">args</span>: { <span class="hljs-keyword">mode</span>: <span class="hljs-string">&quot;normal&quot;</span> } },
    <span class="hljs-string">&quot;evil::j&quot;</span>: <span class="hljs-string">&quot;edit.action.clipbaordCutAction&quot;</span>,
    <span class="hljs-string">&quot;evil::k&quot;</span>: <span class="hljs-string">&quot;edit.action.clipbaordCutAction&quot;</span>,
    <span class="hljs-string">&quot;evil::h&quot;</span>: <span class="hljs-string">&quot;edit.action.clipbaordCutAction&quot;</span>,
    <span class="hljs-string">&quot;evil::l&quot;</span>: <span class="hljs-string">&quot;edit.action.clipbaordCutAction&quot;</span>
}
</code></pre> <h2 id="heading-#keybinding-forms"><a class="header-anchor" id="keybinding-forms" href="#keybinding-forms"> </a>Keybinding forms</h2> <p>You can define the bindings in four different ways. It is also possible to combine them freely.</p> <h3 id="heading-#single-command"><a class="header-anchor" id="single-command" href="#single-command"> </a>Single Command</h3> <p>The simplest way is to map a key to a single command. This has the format:</p> <pre><code class="language-js"><span class="hljs-attr">&quot;&lt;binding&gt;&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;command&gt;&quot;</span>
</code></pre> <p>The <code>&lt;binding&gt;</code> specifies the sequence of keys to press, and <code>&lt;command&gt;</code> is any valid VS Code command. You can see the list of all available commands by opening global settings with command <strong>Preferences: Open Default Keyboard Shortcuts (JSON)</strong>.</p> <p>The example in the previous section maps the <code>i</code> key to the <code>modalkeys.enterInsert</code> command.</p> <h3 id="heading-#commands-with-arguments"><a class="header-anchor" id="commands-with-arguments" href="#commands-with-arguments"> </a>Commands with Arguments</h3> <p>Some <a href="https://code.visualstudio.com/api/references/commands#commands">commands</a> take arguments. For example <code>cursorMove</code> which allows you to specify which direction and how much cursor moves. These commands can be executed by defining an object with predefined properties:</p> <pre><code class="language-js"><span class="hljs-string">&quot;&lt;binding&gt;&quot;</span>:  {
    <span class="hljs-string">&quot;&lt;command&gt;&quot;</span>: { ... }
    <span class="hljs-string">&quot;repeat&quot;</span>: number <span class="hljs-string">| &quot;</span>__count<span class="hljs-string">&quot;</span>
}
</code></pre> <p>The <code>&lt;command&gt;</code> is again a valid VS Code command. Any arguments you wish to pass to this command should be placed inside the curly brackets. ModalKeys evaluates any argument strings that contain <code>__</code> as JavaScript expressions, and replaces the argument value with the result of this evaluation. The following variables are recognized during this evaluation.</p> <table> <thead> <tr><th>Variable</th><th>Type</th><th>Description</th></tr> </thead> <tbody> <tr><td><code>__file</code></td><td><code>string</code></td><td>The name of the current file</td></tr> <tr><td><code>__line</code></td><td><code>number</code></td><td>The line number of cursor location</td></tr> <tr><td><code>__col</code></td><td><code>number</code></td><td>The column number of cursor location</td></tr> <tr><td><code>__char</code></td><td><code>string</code></td><td>The character under the cursor</td></tr> <tr><td><code>__language</code></td><td><code>string</code></td><td>The languageId of the current file</td></tr> <tr><td><code>__selections</code></td><td><a href="https://code.visualstudio.com/api/references/vscode-api#Selection"><code>Selection[]</code></a></td><td>The selection objects of the current editor</td></tr> <tr><td><code>__selection</code></td><td><a href="https://code.visualstudio.com/api/references/vscode-api#Selection"><code>Selection</code></a></td><td>The primary selection object of the current editor</td></tr> <tr><td><code>__selectionstr</code></td><td><code>string</code></td><td>The text of the primary selection</td></tr> <tr><td><code>__selecting</code></td><td><code>bool</code></td><td>True if text should be selected (e.g. we're in visual mode).</td></tr> <tr><td><code>__mode</code></td><td><code>string</code></td><td>A string specifying the current mode</td></tr> <tr><td><code>__count</code></td><td><code>number</code></td><td>A number indicating the prefixed numerical values in front of a command: see below.</td></tr> <tr><td><code>__captured</code></td><td><code>string</code></td><td>The list of captured keys following (see <a href="#capturing-keys"><code>captureChar</code></a>)</td></tr> </tbody> </table> <p>Below is an example that leverages string evaluation. It maps the key <key>o</key> to a command that moves the cursor to the end of the line. It also selects the jumped range, if we have a selection already active.</p> <pre><code class="language-js"><span class="hljs-string">&quot;o&quot;</span>: { <span class="hljs-string">&quot;cursorMove&quot;</span>: { <span class="hljs-keyword">to</span>: <span class="hljs-string">&#x27;wrappedLineEnd&#x27;</span>, <span class="hljs-keyword">select</span>: <span class="hljs-string">&#x27;__selecting&#x27;</span> } },
</code></pre> <h4>Numeric arguments</h4> <p>When you type a modal command you can prefix it with numbers: these are passed using the <code>__count</code> variable to your command.</p> <p>As a full example of using <code>__count</code>, the following would bind h to move left (like vim) in all modes.</p> <pre><code class="language-js">    <span class="hljs-string">&quot;h&quot;</span>: { <span class="hljs-string">&quot;cursorMove&quot;</span>: { <span class="hljs-keyword">to</span>: <span class="hljs-string">&#x27;left&#x27;</span>, value: <span class="hljs-string">&#x27;__count&#x27;</span> } },
</code></pre> <p>Because <code>value</code> is specified as <code>__count</code>, if you typed <code>12h</code>, the cursor would move 12 characters to the left.</p> <h4>Repeating commands</h4> <p>The <code>repeat</code> property of a command allows you to run the command multiple times. If it's a number, it should indicate the number of times to repeat the command. If it's a string it is evaluated as a JavaScript expression, and should evaluate to a numeric or boolean value. If numeric, the command repeats the given number of times. If boolean, it yields while-loop behavior: the command will continue to be repeated until it evaluates to false.</p> <h3 id="heading-#sequence-of-commands"><a class="header-anchor" id="sequence-of-commands" href="#sequence-of-commands"> </a>Sequence of Commands</h3> <p>To construct more complex operations consisting of multiple steps, you can define command sequences. Commands in a sequence will be run one after another. A sequence is defined as an array.</p> <pre><code class="language-js"><span class="hljs-string">&quot;&lt;binding&gt;&quot;</span>: [ &lt;<span class="hljs-keyword">command</span>1&gt;, &lt;<span class="hljs-keyword">command</span>2&gt;, <span class="hljs-string">...</span> ]
</code></pre> <p>In above, <code>&lt;command&gt;</code> can assume any of the four command types.</p> <p>The next example maps the <code>f</code> key to a command sequence that first deletes the selected text and then switch to insert mode. It corresponds to the <code>c</code> command in Vim.</p> <pre><code class="language-js"><span class="hljs-string">&quot;f&quot;</span>: [
    <span class="hljs-string">&quot;deleteRight&quot;</span>,
    <span class="hljs-string">&quot;modaledit.enterInsert&quot;</span>
],
</code></pre> <h3 id="heading-#conditional-commands"><a class="header-anchor" id="conditional-commands" href="#conditional-commands"> </a>Conditional Commands</h3> <p>For even more complex scenarios, you can define commands that run different commands depending on a specified condition. The most common use case for this is to run a different command when selection is active. The format of a conditional commands is:</p> <pre><code class="language-js"><span class="hljs-string">&quot;&lt;binding&gt;&quot;</span>:  {
    <span class="hljs-string">&quot;if&quot;</span>: <span class="hljs-string">&quot;&lt;condition&gt;&quot;</span>,
    <span class="hljs-string">&quot;then&quot;</span>: &lt;comma<span class="hljs-symbol">nd1</span>&gt;,
    <span class="hljs-string">&quot;else&quot;</span>: &lt;comma<span class="hljs-symbol">nd2</span>&gt;,
}
</code></pre> <p>Here <code>&lt;condition&gt;</code> can be any valid JavaScript expression. You can use variables listed in the &quot;Commands with Arguments&quot; section in the expression. If the expression evaluates to true, <code>&lt;command1&gt;</code> will be executed, if false, <code>&lt;command2&gt;</code> will be run. Commands can be of any kind: a single command, sequence, or command with arguments.</p> <p>Below is an example that moves cursor one word forward with <code>w</code> key. We use the <code>__mode</code> variable to determine if we're in visual mode. If so, we extend the selection using <code>cursorWordStartRightSelect</code> command, otherwise we just jump to next word with <code>cursorWordStartRight</code>.</p> <pre><code class="language-js"><span class="hljs-string">&quot;w&quot;</span>: {
    <span class="hljs-string">&quot;if&quot;</span>: <span class="hljs-string">&quot;__mode == &#x27;</span>visual&#x27;<span class="hljs-string">&quot;,
    &quot;</span><span class="hljs-keyword">then</span><span class="hljs-string">&quot;: &quot;</span>cursorWordStartRightSelect<span class="hljs-string">&quot;,
    &quot;</span><span class="hljs-keyword">else</span><span class="hljs-string">&quot;: &quot;</span>cursorWordStartRight<span class="hljs-string">&quot;
},
</span></code></pre> <h3 id="heading-#debugging-keybindings"><a class="header-anchor" id="debugging-keybindings" href="#debugging-keybindings"> </a>Debugging Keybindings</h3> <p>If you are not sure that your bindings are correct, check the ModalKeys's output log. You can find it by opening <strong>View - Output</strong> and then choosing the <strong>ModalKeys</strong> from the drop-down menu. Errors in configuration will be reported there. If your configuration is ok, you should see the following message.</p> <h3 id="heading-#advanced-keybindings"><a class="header-anchor" id="advanced-keybindings" href="#advanced-keybindings"> </a>Advanced Keybindings</h3> <p>You can specify a series of shortcuts that all use the same command, each with different arguments to that same command. Use the following format.</p> <pre><code class="language-js"><span class="hljs-string">&quot;::using::&lt;command&gt;&quot;</span>: {
    <span class="hljs-string">&quot;&lt;binding1&gt;&quot;</span>: { <span class="hljs-string">...</span> },
    <span class="hljs-string">&quot;&lt;binding2&gt;&quot;</span>: { <span class="hljs-string">...</span> },
    <span class="hljs-string">...</span>
}
</code></pre> <p>Each binding is bound to the command <code>&lt;command&gt;</code>, passing the arguments specified for that binding (<code>{...}</code>).</p> <h2 id="heading-#vs-code-commands"><a class="header-anchor" id="vs-code-commands" href="#vs-code-commands"> </a>VS Code Commands</h2> <p>ModalKeys adds several useful commands to VS Code's repertoire. They help you create more Vim-like workflows.</p> <h3 id="heading-#switching-between-modes"><a class="header-anchor" id="switching-between-modes" href="#switching-between-modes"> </a>Switching between Modes</h3> <p>Use the following commands to change the current editor mode. None of the commands require any arguments.</p> <table> <thead> <tr><th>Command</th><th>Description</th></tr> </thead> <tbody> <tr><td><code>modalkeys.toggle</code></td><td>Toggles between modes.</td></tr> <tr><td><code>modalkeys.enterNormal</code></td><td>Switches to normal mode.</td></tr> <tr><td><code>modalkeys.enterInsert</code></td><td>Switches to insert mode.</td></tr> <tr><td><code>modalkeys.toggleSelection</code></td><td>Toggles selection mode on or off. Selection mode is implicitly on whenever editor has text selected.</td></tr> <tr><td><code>modalkeys.enableSelection</code></td><td>Turn selection mode on.</td></tr> <tr><td><code>modalkeys.cancelSelection</code></td><td>Cancel selection mode and clear selection.</td></tr> <tr><td><code>modalkeys.cancelMultipleSelections</code></td><td>Cancel selection mode and clear selections, but preserve multiple cursors.</td></tr> <tr><td><code>modalkeys.enterMode</code></td><td>Enter a given mode, specified by the argument <code>mode</code> (a string).</td></tr> </tbody> </table> <h3 id="heading-#incremental-search"><a class="header-anchor" id="incremental-search" href="#incremental-search"> </a>Incremental Search</h3> <p>The standard search functionality in VS Code is quite clunky for some desirable features of a modal editor, as it opens a dialog which takes you out of the editor. To achieve more fluid searching experience ModalKeys provides incremental search commands that mimic Vim's corresponding operations.</p> <h4><code>modalkeys.search</code></h4> <p>Starts incremental search. The cursor is changed to indicate that editor is in search mode. Normal mode commands are suppressed while incremental search is active. Just type the search string directly without leaving the editor. You can see the searched string in the status bar as well as the search parameters.</p> <p>The command takes following arguments. All of them are optional.</p> <table> <thead> <tr><th>Argument</th><th>Type</th><th>Default</th><th>Description</th></tr> </thead> <tbody> <tr><td><code>backwards</code></td><td><code>boolean</code></td><td><code>false</code></td><td>Search backwards. Default is forwards</td></tr> <tr><td><code>caseSensitive</code></td><td><code>boolean</code></td><td><code>false</code></td><td>Search is case-sensitive. Default is case-insensitive</td></tr> <tr><td><code>wrapAround</code></td><td><code>boolean</code></td><td><code>false</code></td><td>Search wraps around to top/bottom depending on search direction. Default is off.</td></tr> <tr><td><code>acceptAfter</code></td><td><code>number</code></td><td><code>undefined</code></td><td>Accept search automatically after <em>x</em> characters has been entered. This helps implementing quick one or two character search operations.</td></tr> <tr><td><code>selectTillMatch</code></td><td><code>boolean</code></td><td><code>false</code></td><td>Select the range from current position till the match instead of just the match. Useful with <code>acceptAfter</code> to quickly extend selection till the specified character(s).</td></tr> <tr><td><code>highlightMatches</code></td><td><code>boolean</code></td><td><code>true</code></td><td>If true, use the search highlight colors to highlight all matches</td></tr> <tr><td><code>offset</code></td><td><code>string</code></td><td><code>&quot;inclusive&quot;</code></td><td>Where the cursor should land after searching: &quot;inclusive&quot; of match, &quot;exclusive&quot; of match string, at the &quot;start&quot; or at the &quot;end&quot; of the match.</td></tr> <tr><td><code>executeAfter</code></td><td><code>&lt;command&gt;</code></td><td></td><td>The given commands are run after accepting a search</td></tr> <tr><td><code>text</code></td><td><code>string</code></td><td>&quot;&quot;</td><td>If non-empty, run a non-interactive search using the given text</td></tr> <tr><td><code>regex</code></td><td><code>boolean</code></td><td><code>false</code></td><td>If true, interpret search query as a regular expression</td></tr> </tbody> </table> <h4><code>modalkeys.cancelSearch</code></h4> <p>Cancels the incremental search, returns the cursor to the starting position, and switches back to normal mode.</p> <h4><code>modalkeys.deleteCharFromSearch</code></h4> <p>Deletes the last character of the search string. By default the backspace key is bound to this command when ModalKeys is active and in search mode.</p> <h4><code>modalkeys.nextMatch</code></h4> <p>Moves to the next match and selectes it. Which way to search depends on the search direction.</p> <h4><code>modalkeys.previousMatch</code></h4> <p>Moves to the previous match and selectes it. Which way to search depends on the search direction.</p> <h4><code>modalkeys.enterMode</code></h4> <p>This command takes a single argument <code>mode</code> and allows you to enter any mode you desire.</p> <h3 id="heading-#macros"><a class="header-anchor" id="macros" href="#macros"> </a>Macros</h3> <p>ModalKeys can record events from all modes, other than those from insert mode (support for insert mode is <a href="https://github.com/haberdashPI/vscode-modal-keys/issues/5">planned</a>).</p> <p>There are three commands</p> <h4><code>modalkeys.toggleRecordingMacro</code></h4> <p>This starts or stops the recording of a macro. When starting a macro, this command accepts a single argument (<code>register</code>). The register determines what name (or number) the macro is stored under. For example, you could pass <code>__count</code> or use <code>captureChar</code> (documented below) to allow the user to create multiple macros.</p> <p><strong>LIMITATION</strong>: Macro recording currently ignores all <a href="https://github.com/haberdashPI/vscode-modal-keys/issues/5">insert-mode events</a></p> <h4><code>modalkeys.cnacelRecordingMacro</code></h4> <p>This stops macro recording; unlike <code>toggleRecordingMacro</code>, the new recording is forgotten, and any previous recording stored at the given register is retained.</p> <h4><code>modalkeys.replayMacro</code></h4> <p>This replays a given macro, indicated by the argument <code>register</code>.</p> <h3 id="heading-#invoking-key-bindings"><a class="header-anchor" id="invoking-key-bindings" href="#invoking-key-bindings"> </a>Invoking Key Bindings</h3> <p>The command <code>modalkeys.typeKeys</code> invokes commands through key bindings. Calling this command with a key sequence has the same effect as pressing the keys in given mode. This allows you to treat key bindings as subroutines that can be called using this command.</p> <p>The command has two arguments.</p> <ol> <li><code>keys</code>: contains the key sequence as string.</li> <li><code>mode</code>: defaults to 'normal', and specifies what mode the keys should be typed in</li> </ol> <p>Assuming that keys <key>k</key> and <key>u</key> are bound to some commands, the following example runs them both one after another.</p> <pre><code class="language-js"><span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;modaledit.typeKeys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;keys&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ku&quot;</span> <span class="hljs-punctuation">}</span> <span class="hljs-punctuation">}</span>
</code></pre> <h3 id="heading-#repeat-last-change"><a class="header-anchor" id="repeat-last-change" href="#repeat-last-change"> </a>Repeat Last Change</h3> <p><code>modalkeys.repeatLastChange</code> command repeats the last command (sequence) that caused text in the editor to change. It corresponds to the <a href="https://vim.fandom.com/wiki/Repeat_last_change">dot <code>.</code> command</a> in Vim. The command takes no arguments.</p> <h4>Touching/Untouching a document</h4> <p>To register a change to the document you can call <code>modalkeys.touchDoucment</code>, and to ignore the last change you can cal <code>modalkeys.untouchDocument</code>. This can be useful for changing the behavior of <code>repeatLastChange</code>. For example, you might want to treat a command that commits a range of the document to version control, or sends text to a REPL as a change (that can be repeated with <code>repeatLastCahnge</code>).</p> <h3 id="heading-#repeat-last-used-selection"><a class="header-anchor" id="repeat-last-used-selection" href="#repeat-last-used-selection"> </a>Repeat Last Used Selection</h3> <p><code>modalkeys.repeatLastUsedSelection</code> repeats the last command (sequence) that caused the selection to change <em>just before</em> the last change occurred. This is useful for implementing a kakaune-like workflow, where selections are applied and then followed by actions. This is in contrast to the vim-like approach of specifying actions followed by objects (which are kind of like selections, but are not visually displayed). E.g. <key>w</key><key>d</key> in a kakaune-like workflow might select a word (<key>w</key>) and then delete it (<key>d</key>), whereas, in vim, you would type <key>d</key><key>d</key> to delete a word. By repeating the last used selection, you could repeat <key>w</key> and repeating the last change, you could repeat <key>d</key>. Or you could have both repeat commands occur with a single stroke, like below.</p> <pre><code class="language-js">{ <span class="hljs-string">&quot;.&quot;</span>: [ <span class="hljs-string">&quot;modalkeys.repeatLastUsedSelection&quot;</span>, <span class="hljs-string">&quot;modalkeys.repeatLastChange&quot;</span> ] }
</code></pre> <h3 id="heading-#capturing-keys"><a class="header-anchor" id="capturing-keys" href="#capturing-keys"> </a>Capturing keys</h3> <p><code>modalkeys.captureChar</code> is a generic command for capturing a sequence of keys that the user types. It records characters until the user hits return (or until <code>acceptAfter</code> keys are typed). One could implement a poor man's version of the search commands using <code>modalkeys.captureChar</code>. It accepts the following arguments</p> <table> <thead> <tr><th>Argument</th><th>Type</th><th>Default</th><th>Description</th></tr> </thead> <tbody> <tr><td><code>acceptAfter</code></td><td><code>number</code></td><td><code>undefined</code></td><td>Accept search automatically after <em>x</em> characters has been entered.</td></tr> <tr><td><code>execuateAfter</code></td><td>&lt;command&gt;</td><td><code>undefined</code></td><td>The commands to run after capturing keys.</td></tr> </tbody> </table> <p>For example, the following command selects all characters that fall between two instances of a given key; so, in the string &quot;joe |bob| joe&quot;, with the cursor on the first &quot;b&quot;, typing <code>uc|</code> would select &quot;bob&quot;.</p> <pre><code class="language-js">    <span class="hljs-attr">uc:</span> { <span class="hljs-attr">&quot;modalkeys.captureChar&quot;:</span> {
        <span class="hljs-attr">acceptAfter:</span> <span class="hljs-number">1</span>,
        <span class="hljs-attr">executeAfter:</span> { <span class="hljs-attr">&quot;modalkeys.selectBetween&quot;:</span> {
            <span class="hljs-attr">from:</span> <span class="hljs-string">&quot;__captured&quot;</span>,
            <span class="hljs-attr">to:</span> <span class="hljs-string">&quot;__captured&quot;</span>,
            <span class="hljs-attr">inclusive:</span> <span class="hljs-literal">false</span>,
            <span class="hljs-attr">caseSensitive:</span> <span class="hljs-literal">true</span>,
            <span class="hljs-attr">docScope:</span> <span class="hljs-literal">true</span>
        }},
    }}<span class="hljs-string">,</span>
</code></pre> <h2 id="heading-#configuration"><a class="header-anchor" id="configuration" href="#configuration"> </a>Configuration</h2> <h3 id="heading-#changing-cursors"><a class="header-anchor" id="changing-cursors" href="#changing-cursors"> </a>Changing Cursors</h3> <p>You can set the cursor shape shown in each mode by changing the following settings. Custom modes always use the cursor style of Normal mode.</p> <table> <thead> <tr><th>Setting</th><th>Default</th><th>Description</th></tr> </thead> <tbody> <tr><td><code>insertCursorStyle</code></td><td><code>line</code></td><td>Cursor shown in insert mode.</td></tr> <tr><td><code>normalCursorStyle</code></td><td><code>block</code></td><td>Cursor shown in normal mode.</td></tr> <tr><td><code>searchCursorStyle</code></td><td><code>underline</code></td><td>Cursor shown when incremental search is on.</td></tr> <tr><td><code>selectCursorStyle</code></td><td><code>line-thin</code></td><td>Cursor shown when selection is active in normal mode.</td></tr> </tbody> </table> <p>The possible values are:</p> <ul> <li><code>block</code></li> <li><code>block-outline</code></li> <li><code>line</code></li> <li><code>line-thin</code></li> <li><code>underline</code></li> <li><code>underline-thin</code></li> </ul> <h3 id="heading-#changing-search-highlight-colors"><a class="header-anchor" id="changing-search-highlight-colors" href="#changing-search-highlight-colors"> </a>Changing Search Highlight Colors</h3> <p>By default, incremental search highlights matches in the same way that the built-in search command does. You can configure it to use a different set of colors using the following settings. Leave these blanks to use the theme colors for built-in search commands.</p> <table> <thead> <tr><th>Setting</th><th>Default</th><th>Description</th></tr> </thead> <tbody> <tr><td><code>searchMatchBackground</code></td><td>``</td><td>Background color for current search match.</td></tr> <tr><td><code>searchMatchBorder</code></td><td>``</td><td>Border color for current search match.</td></tr> <tr><td><code>searchOtherMatchesBackground</code></td><td>``</td><td>Background color for other visible search matches.</td></tr> <tr><td><code>searchOtherMatchesBorder</code></td><td>``</td><td>Border color for other visible search matches .</td></tr> </tbody> </table> <h3 id="heading-#changing-status-bar"><a class="header-anchor" id="changing-status-bar" href="#changing-status-bar"> </a>Changing Status Bar</h3> <p>You can change the text shown in status bar in each mode along with the text color. Note that you can add icons in the text by using syntax <code>$(icon-name)</code> where <code>icon-name</code> is a valid name from the gallery of <a href="https://microsoft.github.io/vscode-codicons/dist/codicon.html">built-in icons</a>.</p> <p>The color of the status text is specified in HTML format, such as <code>#ffeeff</code>, <code>cyan</code>, or <code>rgb(50, 50, 50)</code>. By default these colors are not defined, and thus they are same as the rest of text in the status bar.</p> <table> <thead> <tr><th>Setting</th><th>Default</th><th>Description</th></tr> </thead> <tbody> <tr><td><code>insertStatusText</code></td><td><code>-- $(edit) INSERT --</code></td><td>Status text shown in insert mode</td></tr> <tr><td><code>normalStatusText</code></td><td><code>-- $(move) __MODENAME__ --</code></td><td>Status text shown in normal, or custom modes</td></tr> <tr><td><code>searchStatusText</code></td><td><code>$(search) SEARCH</code></td><td>Status text shown when search is active</td></tr> <tr><td><code>selectStatusText</code></td><td><code>-- $(paintcan) VISUAL --</code></td><td>Status text shown when selection is active in normal mode</td></tr> <tr><td><code>insertStatusColor</code></td><td><code>undefined</code></td><td>Status text color in insert mode</td></tr> <tr><td><code>normalStatusColor</code></td><td><code>undefined</code></td><td>Status text color in normal mode</td></tr> <tr><td><code>searchStatusColor</code></td><td><code>undefined</code></td><td>Status text color when search is active</td></tr> <tr><td><code>selectStatusColor</code></td><td><code>undefined</code></td><td>Status text color when selection is active in normal mode</td></tr> </tbody> </table> <h3 id="heading-#start-in-normal-mode"><a class="header-anchor" id="start-in-normal-mode" href="#start-in-normal-mode"> </a>Start in Normal Mode</h3> <p>If you want VS Code to be in insert mode when it starts, set the <code>startInNormalMode</code> setting to <code>false</code> (it defaults to <code>true</code>).</p> <a href="https://github.com/haberdashPI/vscode-modal-keys">View on GitHub</a> </div> </body></html>
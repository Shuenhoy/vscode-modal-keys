
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>ModalKeys - Tutorial</title>
    <link rel="icon" type="image/icon" href="images/favicon.png" />
    <link rel="stylesheet" href="css/main.css" />


</head>
<body>

    <div class="navbar">
        <div class="navmenu">

    <a class="title enabled" href="index.html">
        <img src="images/escape.svg" />
        <span>ModalKeys</span>
    </a>
    <a class="enabled" href="https://marketplace.visualstudio.com/items?itemName=johtela.vscode-modaledit">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><path d="M537.6 226.6c4.1-10.7 6.4-22.4 6.4-34.6 0-53-43-96-96-96-19.7 0-38.1 6-53.3 16.2C367 64.2 315.3 32 256 32c-88.4 0-160 71.6-160 160 0 2.7.1 5.4.2 8.1C40.2 219.8 0 273.2 0 336c0 79.5 64.5 144 144 144h368c70.7 0 128-57.3 128-128 0-61.9-44-113.6-102.4-125.4zm-132.9 88.7L299.3 420.7c-6.2 6.2-16.4 6.2-22.6 0L171.3 315.3c-10.1-10.1-2.9-27.3 11.3-27.3H248V176c0-8.8 7.2-16 16-16h48c8.8 0 16 7.2 16 16v112h65.4c14.2 0 21.4 17.2 11.3 27.3z"/></svg>
        <span>Download</span>
    </a>
    <a class="enabled" href="https://github.com/johtela/vscode-modaledit">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
        <span>GitHub</span>
    </a>
    <a class="enabled" href="LICENSE.html">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path d="M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zM64 72c0-4.42 3.58-8 8-8h80c4.42 0 8 3.58 8 8v16c0 4.42-3.58 8-8 8H72c-4.42 0-8-3.58-8-8V72zm0 64c0-4.42 3.58-8 8-8h80c4.42 0 8 3.58 8 8v16c0 4.42-3.58 8-8 8H72c-4.42 0-8-3.58-8-8v-16zm192.81 248H304c8.84 0 16 7.16 16 16s-7.16 16-16 16h-47.19c-16.45 0-31.27-9.14-38.64-23.86-2.95-5.92-8.09-6.52-10.17-6.52s-7.22.59-10.02 6.19l-7.67 15.34a15.986 15.986 0 0 1-14.31 8.84c-.38 0-.75-.02-1.14-.05-6.45-.45-12-4.75-14.03-10.89L144 354.59l-10.61 31.88c-5.89 17.66-22.38 29.53-41 29.53H80c-8.84 0-16-7.16-16-16s7.16-16 16-16h12.39c4.83 0 9.11-3.08 10.64-7.66l18.19-54.64c3.3-9.81 12.44-16.41 22.78-16.41s19.48 6.59 22.77 16.41l13.88 41.64c19.77-16.19 54.05-9.7 66 14.16 2.02 4.06 5.96 6.5 10.16 6.5zM377 105L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128v-6.1c0-6.3-2.5-12.4-7-16.9z"/></svg>
        <span>License</span>
    </a>
    <a class="enabled" href="README.html">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M223.7 239l136-136c9.4-9.4 24.6-9.4 33.9 0l22.6 22.6c9.4 9.4 9.4 24.6 0 33.9L319.9 256l96.4 96.4c9.4 9.4 9.4 24.6 0 33.9L393.7 409c-9.4 9.4-24.6 9.4-33.9 0l-136-136c-9.5-9.4-9.5-24.6-.1-34zm-192 34l136 136c9.4 9.4 24.6 9.4 33.9 0l22.6-22.6c9.4-9.4 9.4-24.6 0-33.9L127.9 256l96.4-96.4c9.4-9.4 9.4-24.6 0-33.9L201.7 103c-9.4-9.4-24.6-9.4-33.9 0l-136 136c-9.5 9.4-9.5 24.6-.1 34z"/></svg>
        <span>Previous: Home</span>
    </a>
    <a class="enabled" href="presets/vim.html">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34zm192-34l-136-136c-9.4-9.4-24.6-9.4-33.9 0l-22.6 22.6c-9.4 9.4-9.4 24.6 0 33.9l96.4 96.4-96.4 96.4c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l136-136c9.4-9.2 9.4-24.4 0-33.8z"/></svg>
        <span>Next: Vim Presets</span>
    </a>
        </div>

    <a class="hamburger">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
    </a>
    </div>

    <div class="layout">
        <div class="sidepane collapsible">

    <div class="tocmenu">
        <h3>Table of Contents</h3>

    <ul>

    <li>

        <a href="README.html">Home</a>

    </li>
    <li>

        <a href="tutorial.html" class="highlight">Tutorial</a>

    </li>
    <li>

        <a href="presets/vim.html">Vim Presets</a>

    </li>
    <li>
        <button class="accordion">
        Implementation
        </button>

    <ul>

    <li>

        <a href="src/extension.html">Extension</a>

    </li>
    <li>

        <a href="src/actions.html">Actions</a>

    </li>
    <li>

        <a href="src/commands.html">Commands</a>

    </li>
    </ul>
    </li>
    <li>

        <a href="CHANGELOG.html">Change Log</a>

    </li>
    <li>

        <a href="LICENSE.html">License</a>

    </li>
    </ul>
    </div>

    <div class="footer">
        Copyright Â© 2020 Tommi Johtela
        <div class="ad">
            Created with <a href="https://github.com/johtela/litscript">LiTScript</a>
        </div>
    </div>

        </div>
        <div class="sideicon collapsible">

    <a class="hamburger">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
    </a>
        </div>
        <div class="scrollingarea closepopups">

    <div class="contentarea">
        <h1 id="build-your-own-vim-emulation-for-vs-code">Build Your Own Vim Emulation for VS Code</h1>
<p><img src="../images/sharks.png" alt="Shark" width="256" height="206">
<a href="https://www.vim.org/">Vim</a> is the great white shark of text editors. It has survived among modern
IDEs because of its unique philosophy. It supports <a href="https://unix.stackexchange.com/questions/57705/modeless-vs-modal-editors">modal editing</a> which is
almost an opposite approach to how other editors work. You start in &quot;normal&quot;
mode where you can navigate and edit text but not insert it. When you want to
enter text, you switch to &quot;insert&quot; mode where you can type new text but do
nothing else. So, you end up bouncing between modes as you edit your file.</p>
<p>This might sound difficult, and granted, the learning curve is steep. But after
you are accustomed to this way of editing, it is very difficult to go back. For
example, having to use arrow keys to move cursor feels uncomfortable. The proof
of this is that nearly all popular text editors have some kind of add-in that
provides Vim emulation. VS Code has several of them.</p>
<p>So, why write yet another extension that provides Vim emulation? Well, the
problem is that most emulators try to make VS Code behave exactly like Vim which
quickly becomes an exercise in futility. Trying to mimick Vim's functionality
too closely results in disjointed user experience as it has a lot of features
that do not have counterparts in VS Code.</p>
<p><a href="../README.html">ModalKeys's</a> approach is to utilize VS Code's existing features and
just add the concept of modal editing to the mix. Turns out implementing modal
editing is extremely simple. We basically provide pair of commands that switch
between normal mode and insert mode.</p>
<p>To complete the feature set, we need an ability to bind normal mode key
sequences to VS Code's commands. ModalKeys accomplishes this by defining the key
bindings in the VS Code's standard configuration file <code>settings.json</code>. It allows
binding any key to any command, or a sequence of commands. It supports also
conditional commands that do different things based on editor state. Refer to
the <a href="../README.html">README</a> page for the details of the configuration options.</p>
<p>With these capabilities we can start building our Vim emulation. We don't have
to use Vim's standard key bindings, if we prefer not to. You can map any key
(sequence) to any command. But to keep things familiar, we'll follow Vim's
conventions in this tutorial.</p>
<p>Let's start configuring our Vim emulator by adding the ModalKeys's configuration
block for key bindings. We'll use the <a href="https://vim.rtorr.com/">Vim Cheat Sheet</a> as our specification
for key bindings to be added.</p>

<pre class="syntaxhighlight"><code>{
    <span class="string">"modaledit.keybindings"</span>: {
</code></pre>
<h2 id="switching-between-modes">Switching Between Modes</h2>
<p>First things first: we need to be able to enter the normal mode somehow. The
<key>Esc</key> key is mapped to the <code>modaledit.enterNormal</code> command by default,
so we dont't need to do anything for that. If you like, you can map other keys to
this command using VS Code's standard keymappings pressing
<key>Ctrl</key>+<key>K</key> <key>Ctrl</key>+<key>S</key>.</p>
<h3 id="insert-text">Insert Text</h3>
<p>There are multiple ways to enter insert mode. If you want to insert text in the
current cursor position, you press <key>i</key>.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"i"</span>: <span class="string">"modaledit.enterInsert"</span>,
</code></pre>
<p>To insert text at the beginning of line, you press <key>I</key>. For this
operation, we need a command sequence, i.e. an array of commands.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"I"</span>: [
            <span class="string">"cursorHome"</span>,
            <span class="string">"modaledit.enterInsert"</span>
        ],
</code></pre>
<h3 id="append-text">Append Text</h3>
<p><em>Appending</em> text works analogously; <key>a</key> appends text after current
character and <key>A</key> at the end of the line. There is a special case,
though. If cursor is already at the last character of the line, it should not
move. This is why we use a conditional command to move the cursor only, if the
current character is not an empty string which marks the end of the line. A
conditional command is an object that contains the <code>condition</code> property. The
value of the property is a JS expression which ModalKeys evaluates. It selects
the command based on the result. In this case, the result <code>false</code> will execute
the <code>cursorRight</code> command.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"a"</span>: [
            {
                <span class="string">"condition"</span>: <span class="string">"__char == ''"</span>,
                <span class="string">"false"</span>: <span class="string">"cursorRight"</span>
            },
            <span class="string">"modaledit.enterInsert"</span>
        ],
        <span class="string">"A"</span>: [
            <span class="string">"cursorEnd"</span>,
            <span class="string">"modaledit.enterInsert"</span>
        ],
</code></pre>
<h3 id="open-a-new-line">Open a New Line</h3>
<p>The third way to enter insert mode is to <em>open</em> a line. This means creating an
empty line, and putting the cursor on it. There are two variants of this command
as well: <key>o</key> opens a new line below the current line whereas
<key>O</key> opens it on the current line.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"o"</span>: [
            <span class="string">"editor.action.insertLineAfter"</span>,
            <span class="string">"modaledit.enterInsert"</span>
        ],
        <span class="string">"O"</span>: [
            <span class="string">"editor.action.insertLineBefore"</span>,
            <span class="string">"modaledit.enterInsert"</span>
        ],
</code></pre>
<p>Now we can test the commands we just created.</p>
<p><img src="../images/mode-switching.gif" alt="mode switching"></p>
<h2 id="cursor-movement">Cursor Movement</h2>
<p>The next task in hand is to add commands for moving the cursor. As all Vim users
know, instead of arrow keys, we move the cursor with <key>h</key>, <key>j</key>,
<key>k</key>, and <key>l</key> keys. Before implementing these, let's talk a bit
about text selection.</p>
<h3 id="selecting-text">Selecting Text</h3>
<p>In Vim, there is a separate &quot;visual&quot; mode that you activate when you want to
select text. Visual mode can be characterwise or linewise. VS Code has no
simillar concept. By contrast, to select text you move the cursor with
<key>Shift</key> key depressed.</p>
<p>ModalKeys bridges this gap by providing the special command
<code>modaledit.toggleSelection</code> which toggles selection mode on and off. Selection
mode is not really a mode in the same sense as normal and insert mode are; you
can select text both in normal mode and insert mode. Rather it is an additional
flag that you can set when you want to select text as you move the cursor.</p>
<p>Selection mode is also implicitly on whenever there is text selected. If you
select text with mouse, for example, the selection mode is turned on (Vim
behaves like this too). To turn off the selection mode, call
<code>modaledit.toggleSelection</code> again (or <code>modaledit.clearSelection</code>).</p>
<p>The end result is that selection mode works <em>almost</em> like visual mode in Vim,
the main difference being that selection mode is not automatically turned off
when you enter insert mode.</p>
<p>So, let's add a binding to toggle selection mode on or off. We use the familiar
<key>v</key> key for this.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"v"</span>: <span class="string">"modaledit.toggleSelection"</span>,
</code></pre>
<p>Now we can add commands for cursor movement. These commands use the generic
<a href="https://code.visualstudio.com/api/references/commands"><code>cursorMove</code> command</a> which takes arguments. The arguments we use
are partly constant and partly dynamic. Therefore, we use ModalKeys's feature
which allows us to define parameters as a JS expression. The <code>__selecting</code> flag
in the expression indicates whether selection mode is on. The same effect could
be achieved also with a conditional command, but this way is a bit simpler.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"h"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'left', select: __selecting }"</span>
        },
        <span class="string">"j"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'down', select: __selecting }"</span>
        },
        <span class="string">"k"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'up', select: __selecting }"</span>
        },
        <span class="string">"l"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'right', select: __selecting }"</span>
        },
</code></pre>
<p>We can also simulate linewise visual mode using VS Code's <code>expandLineSelection</code>
command. Note that we don't need to call <code>modaledit.toggleSelection</code> this time
as selection mode is turned on automatically.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"V"</span>: <span class="string">"expandLineSelection"</span>,
</code></pre>
<h3 id="moving-inside-screen">Moving Inside Screen</h3>
<p>To move cursor quickly to the top, middle, or bottom of the screen we use keys
<key>H</key>, <key>M</key>, and <key>L</key>. Again, we need to use the
<a href="https://code.visualstudio.com/api/references/commands"><code>cursorMove</code> command</a>.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"H"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'viewPortTop', select: __selecting }"</span>
        },
        <span class="string">"M"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'viewPortCenter', select: __selecting }"</span>
        },
        <span class="string">"L"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'viewPortBottom', select: __selecting }"</span>
        },
</code></pre>
<h3 id="jumping-to-previous-next-word">Jumping to Previous/Next Word</h3>
<p>Other commonly used navigation commands in Vim include <key>w</key> and
<key>b</key> which move the cursor to the start of the next and previous word.
For these we need to use conditional commands because <code>cursorMove</code> falls short
in this use case.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"w"</span>: {
            <span class="string">"condition"</span>: <span class="string">"__selecting"</span>,
            <span class="string">"true"</span>: <span class="string">"cursorWordStartRightSelect"</span>,
            <span class="string">"false"</span>: <span class="string">"cursorWordStartRight"</span>
        },
        <span class="string">"b"</span>: {
            <span class="string">"condition"</span>: <span class="string">"__selecting"</span>,
            <span class="string">"true"</span>: <span class="string">"cursorWordStartLeftSelect"</span>,
            <span class="string">"false"</span>: <span class="string">"cursorWordStartLeft"</span>
        },
</code></pre>
<p><key>e</key> jumps to the end of the next word.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"e"</span>: {
            <span class="string">"condition"</span>: <span class="string">"__selecting"</span>,
            <span class="string">"true"</span>: <span class="string">"cursorWordEndRightSelect"</span>,
            <span class="string">"false"</span>: <span class="string">"cursorWordEndRight"</span>
        },
</code></pre>
<blockquote>
<p><strong>Note</strong>: We omit variants of these commands <key>W</key>, <key>B</key>, and
<key>E</key> which skip the punctuation characters. There are no built-in
commands in VS Code that work exactly like those in Vim. This is one of the
subtle differences between the editors.</p>
</blockquote>
<h3 id="jumping-to-start-end-of-line">Jumping to Start/End of Line</h3>
<p>In the similar vein, we'll throw in commands for jumping to the beginning
<key>0</key>, to the first non-blank character <key>^</key>, and to the end of
line <key>$</key>.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"0"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'wrappedLineStart', select: __selecting }"</span>
        },
        <span class="string">"^"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'wrappedLineFirstNonWhitespaceCharacter', select: __selecting }"</span>
        },
        <span class="string">"$"</span>: {
            <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
            <span class="string">"args"</span>: <span class="string">"{ to: 'wrappedLineEnd', select: __selecting }"</span>
        },
</code></pre>
<p>A lesser known variant of above commands is <key>g</key><key>_</key> that jumps
to the last non-blank character of the line. Since it is a two key sequence we
need to open a block for all commands beginning with <key>g</key>.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"g"</span>: {
            <span class="string">"_"</span>: {
                <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
                <span class="string">"args"</span>: <span class="string">"{ to: 'wrappedLineLastNonWhitespaceCharacter', select: __selecting }"</span>
            },
</code></pre>
<h3 id="jumping-to-start-end-of-document">Jumping to Start/End of Document</h3>
<p>Another motion command is <key>g</key><key>g</key> which jumps to the beginning
of the file.</p>

<pre class="syntaxhighlight"><code>            <span class="string">"g"</span>: {
                <span class="string">"condition"</span>: <span class="string">"__selecting"</span>,
                <span class="string">"true"</span>: <span class="string">"cursorTopSelect"</span>,
                <span class="string">"false"</span>: <span class="string">"cursorTop"</span>
            },
        },
</code></pre>
<p>The opposite of that is <key>G</key> wich jumps to the end of file.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"G"</span>: {
            <span class="string">"condition"</span>: <span class="string">"__selecting"</span>,
            <span class="string">"true"</span>: <span class="string">"cursorBottomSelect"</span>,
            <span class="string">"false"</span>: <span class="string">"cursorBottom"</span>
        },
</code></pre>
<h3 id="jump-to-character">Jump to Character</h3>
<p>We have the basic movement commands covered, so let's move on to more
sophisticated ones. Seasoned Vim users avoid hitting movement commands
repeatedly by using <key>f</key> and <key>F</key> keys which move directly to a
given character. VS Code provides no built-in command for this, but ModalKeys
includes an incremental search command which can be customized to this purpose.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"f"</span>: {
            <span class="string">"condition"</span>: <span class="string">"__selecting"</span>,
            <span class="string">"true"</span>: {
                <span class="string">"command"</span>: <span class="string">"modaledit.search"</span>,
                <span class="string">"args"</span>: {
                    <span class="string">"caseSensitive"</span>: <span class="literal">true</span>,
                    <span class="string">"acceptAfter"</span>: <span class="number">1</span>,
                    <span class="string">"selectTillMatch"</span>: <span class="literal">true</span>,
                }
            },
            <span class="string">"false"</span>: {
                <span class="string">"command"</span>: <span class="string">"modaledit.search"</span>,
                <span class="string">"args"</span>: {
                    <span class="string">"caseSensitive"</span>: <span class="literal">true</span>,
                    <span class="string">"acceptAfter"</span>: <span class="number">1</span>,
                    <span class="string">"typeAfterAccept"</span>: <span class="string">"h"</span>,
                }
            },
        },
</code></pre>
<p>The command is a bit involved, so let's explain what each argument does.</p>
<ul>
<li><code>caseSensitive</code> sets the search mode to case sensitive (as in Vim).</li>
<li><code>acceptAfter</code> ends the incremental search as soon as first entered character
is found. Normally the user needs to press <key>Enter</key> to accept the
search or <key>Esc</key> to cancel it.</li>
<li><code>selectTillMatch</code> argument controls whether selection is extended until the
searched character. This depends on whether we have selection mode on or not.</li>
<li><code>typeAfterAccept</code> argument allows you to run other commands (using their key
bindings) after the search is done. By default, <code>modalEdit.search</code> command
selects the found character(s). With <key>h</key> command we move the cursor
over the searched character.</li>
</ul>
<p>Now we can implement the opposite <key>F</key> command which searches for the
previous character. The <code>backwards</code> parameter switches the search direction.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"F"</span>: {
            <span class="string">"condition"</span>: <span class="string">"__selecting"</span>,
            <span class="string">"true"</span>: {
                <span class="string">"command"</span>: <span class="string">"modaledit.search"</span>,
                <span class="string">"args"</span>: {
                    <span class="string">"caseSensitive"</span>: <span class="literal">true</span>,
                    <span class="string">"acceptAfter"</span>: <span class="number">1</span>,
                    <span class="string">"selectTillMatch"</span>: <span class="literal">true</span>,
                    <span class="string">"backwards"</span>: <span class="literal">true</span>,
                }
            },
            <span class="string">"false"</span>: {
                <span class="string">"command"</span>: <span class="string">"modaledit.search"</span>,
                <span class="string">"args"</span>: {
                    <span class="string">"caseSensitive"</span>: <span class="literal">true</span>,
                    <span class="string">"acceptAfter"</span>: <span class="number">1</span>,
                    <span class="string">"typeAfterAccept"</span>: <span class="string">"h"</span>,
                    <span class="string">"backwards"</span>: <span class="literal">true</span>
                }
            },
        },
</code></pre>
<p>With <key>;</key> and <key>,</key> keys you can repeat the previous <key>f</key>
or <key>F</key> commands either forwards or backwards.</p>

<pre class="syntaxhighlight"><code>        <span class="string">";"</span>: <span class="string">"modaledit.nextMatch"</span>,
        <span class="string">","</span>: <span class="string">"modaledit.previousMatch"</span>,
</code></pre>
<blockquote>
<p>We omitted few useful jump commands, like <key>t</key>, <key>T</key>,
<key>{</key>, and <key>}</key> as there are no corresponding commands in
available in VS Code. You can always look for other <a href="https://marketplace.visualstudio.com/">extensions</a> that
provide similar functionality.</p>
</blockquote>
<h3 id="center-cursor-on-screen">Center Cursor on Screen</h3>
<p>The last movement command we add is <key>z</key><key>z</key> that scrolls the
screen so that cursor is at the center. Again, the ability to use JS expression
in arguments comes in handy. We use the <code>__line</code> parameter to get the line where
the cursor is.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"z"</span>: {
            <span class="string">"z"</span>: {
                <span class="string">"command"</span>: <span class="string">"revealLine"</span>,
                <span class="string">"args"</span>: <span class="string">"{ lineNumber: __line, at: 'center' }"</span>
            }
        },
</code></pre>
<p>Let's test some of the movement commands. We should be able to navigate now
without using arrow keys or <key>Home</key> and <key>End</key> keys.</p>
<p><img src="../images/cursor-movement.gif" alt="Navigation"></p>
<p>We skipped commands that move cursor up and down on page at the time. The
reason for this is that these commands are bound to <key>Ctrl</key>+<key>b</key>
and <key>Ctrl</key>+<key>f</key> in Vim. Since these are &quot;normal&quot; VS Code
shortcuts we cannot remap them in ModalKeys. If you want to use these shortcuts,
you need to add the bindings to the VS Code's <code>keybindings.json</code> file. Below is
an example that uses the <code>modaledit.normal</code> context to make the shortcuts work
only in normal mode. Most of the Vim's standard <key>Ctrl</key>+key combinations
are already in use, so you need to decide whether you want to remap the existing
commands first.</p>

<pre class="syntaxhighlight"><code><span class="comment">// keybindings.json</span>
{
    {
        <span class="string">"key"</span>: <span class="string">"ctrl+b"</span>,
        <span class="string">"command"</span>: <span class="string">"cursorPageUp"</span>,
        <span class="string">"when"</span>: <span class="string">"editorTextFocus &amp;&amp; modaledit.normal"</span>
    },
    {
        <span class="string">"key"</span>: <span class="string">"ctrl+f"</span>,
        <span class="string">"command"</span>: <span class="string">"cursorPageDown"</span>,
        <span class="string">"when"</span>: <span class="string">"editorTextFocus &amp;&amp; modaledit.normal"</span>
    }
}
</code></pre>
<h2 id="commands-with-counts">Commands with Counts</h2>
<p>Some commands allow repeating them by typing first a number. For example,
<key>3</key><key>j</key> moves the cursor down three lines. Implementing these
kind of commands is possible starting from ModalKeys version 1.5 which
introduced key ranges and <a href="https://johtela.github.io/vscode-modaledit/docs/README.html#defining-recursive-keymaps">recursive keymaps</a>.</p>
<p>First of all, we define a keymap that is activated when pressing a number key
<key>1</key>-<key>9</key>. We give the keymap an unique <code>id</code> which we can then
recursively &quot;call&quot;. We also add a <code>help</code> string that is shown in the status when
the keymap is active (after user has pressed a number key).</p>
<p>Then we define the recursive part; we want to stay in the same keymap as long
as user presses another number key. We implement this by defining inner key
range <key>0</key>-<key>9</key> which maps to the <code>id</code> 1. Whenever you specify a
number as the target for a mapping, ModalKeys treats it as an <code>id</code> that has to
be assigned to a previously defined keymap. In this case we map back to the same
keymap, but you can also jump to other keymaps too.</p>
<p>When the user presses some other than numeric key, we break out from the loop
and run an actual command. The number that was typed is stored in the <code>__keys</code>
variable which is available to all JS expressions. In this case we use it to get
the repeat count as a number. The JS expression in the <code>repeat</code> argument does
just this. We also get the actual command from the last item of the <code>__keys</code>
array and pass it to the <code>modaledit.typeNormalKeys</code> which runs the command
mapped to the key.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"1-9"</span>: {
            <span class="string">"id"</span>: <span class="number">1</span>,
            <span class="string">"help"</span>: <span class="string">"Enter count followed by [h,j,k,l,w,b,e]"</span>,
            <span class="string">"0-9"</span>: <span class="number">1</span>,
            <span class="string">"h,j,k,l,w,b,e"</span>: {
                <span class="string">"command"</span>: <span class="string">"modaledit.typeNormalKeys"</span>,
                <span class="string">"args"</span>: <span class="string">"{ keys: __keys[__keys.length - 1] }"</span>,
                <span class="string">"repeat"</span>: <span class="string">"Number(__keys.slice(0, -1).join(''))"</span>
            },
</code></pre>
<p>With this one reletively simply mapping we can implement the repeating
functionality for any command that we have already defined.</p>
<h3 id="jumping-to-line">Jumping to Line</h3>
<p>Another command that has a number prefix is <em>x</em><key>G</key> where <em>x</em> is the
line number you want to jump to. Let's add that as well in the same keymap.
While the mapping is trivial the command itself is a bit involved, because we
need to use two commands to do the jumping. First we move the target line to the
top of the screen, and then we move the cursor to the same line. Unfortunately
the built-in command <code>workbench.action.gotoLine</code> does not take any arguments, so
we have to reinvent the wheel.</p>

<pre class="syntaxhighlight"><code>            <span class="string">"G"</span>: [
                {
                    <span class="string">"command"</span>: <span class="string">"revealLine"</span>,
                    <span class="string">"args"</span>: <span class="string">"{ lineNumber: Number(__keys.slice(0, -1).join('')) - 1, at: 'top' }"</span>
                },
                {
                    <span class="string">"command"</span>: <span class="string">"cursorMove"</span>,
                    <span class="string">"args"</span>: {
                        <span class="string">"to"</span>: <span class="string">"viewPortTop"</span>
                    }
                }
            ]
        },
</code></pre>
<h2 id="editing">Editing</h2>
<p>Now we'll implement Vim's common editing commands. We only add the ones that
have counterparts in VS Code.</p>
<h3 id="joining-lines">Joining Lines</h3>
<p><key>J</key> joins current and next line together.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"J"</span>: <span class="string">"editor.action.joinLines"</span>,
</code></pre>
<h3 id="changing-text">Changing Text</h3>
<p><em>Change</em> commands delete some text and then enter insert mode.
<key>c</key><key>c</key> changes the current line (or all selected lines),
<key>c</key><key>$</key> changes the text from the cursor to the end of line,
and <key>c</key><key>w</key> changes the end of the word. Three key sequnce
<key>c</key><key>i</key><key>w</key> changes the whole word under the cursor.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"c"</span>: {
            <span class="string">"c"</span>: [
                <span class="string">"deleteAllLeft"</span>,
                <span class="string">"deleteAllRight"</span>,
                <span class="string">"modaledit.enterInsert"</span>
            ],
            <span class="string">"$"</span>: [
                <span class="string">"deleteAllRight"</span>,
                <span class="string">"modaledit.enterInsert"</span>
            ],
            <span class="string">"w"</span>: [
                <span class="string">"deleteWordEndRight"</span>,
                <span class="string">"modaledit.enterInsert"</span>
            ],
</code></pre>
<h3 id="change-until-around-inside">Change Until/Around/Inside</h3>
<p>Very useful variants of change commands are those which allow changing text
upto a given character or between given characters. For example,
<key>c</key><key>t</key><key>_</key> changes the text until next underscore, and
<key>c</key><key>i</key><key>&quot;</key> changes the text inside quotation
marks. The cursor can be anywhere inside the quotation marks and the command
still works.</p>
<p>To help implement these type of operations version 1.6 included the
<a href="https://johtela.github.io/vscode-modaledit/docs/README.html#selecting-text-between-delimiters"><code>modaledit.selectBetween</code> command</a>. It is a swiss army knife
type of command that serves many use cases. We use it first to implement the
&quot;change until&quot; commands: <key>c</key><key>t</key><em>x</em> changes the text from the
cursor till the next occurrence of <em>x</em>. <key>c</key><key>f</key><em>x</em> does the
same and deletes <em>x</em> too.</p>

<pre class="syntaxhighlight"><code>            <span class="string">"t,f"</span>: {
                <span class="string">"help"</span>: <span class="string">"Change until _"</span>,
                <span class="string">" -~"</span>: [
                    {
                        <span class="string">"command"</span>: <span class="string">"modaledit.selectBetween"</span>,
                        <span class="string">"args"</span>: <span class="string">"{ to: __keys[2], inclusive: __keys[1] == 'f' }"</span>
                    },
                    <span class="string">"deleteLeft"</span>,
                    <span class="string">"modaledit.enterInsert"</span>
                ]
            },
</code></pre>
<p>We exploit key ranges to capture all visible ASCII character from spacebar to
tilde. We find the next occurrence of the character typed last (found in
<code>__keys[2]</code>) and select the range. Note that <code>selectBetween</code> only searches till
the end of the current line by default. If you want to search till the end of
the whole document, set the <code>docScope</code> flag to <code>true</code>. When only the <code>to</code>
argument is specified, the selection starts from the cursor position.</p>
<p>If the user pressed <key>f</key> instead of <key>t</key> as the second key in
the sequence, we set the <code>inclusive</code> flag to true. That extends the selection
over the searched character.</p>
<p>Next we add the change around/inside commands. The first variant takes care of
the characters that are not braces.</p>

<pre class="syntaxhighlight"><code>            <span class="string">"a,i"</span>: {
                <span class="string">"help"</span>: <span class="string">"Change around/inside _"</span>,
                <span class="string">" -/,:-@,[-`,{-~"</span>: [
                    {
                        <span class="string">"command"</span>: <span class="string">"modaledit.selectBetween"</span>,
                        <span class="string">"args"</span>: <span class="string">"{ from: __keys[2], to: __keys[2], inclusive: __keys[1] == 'a' }"</span>
                    },
                    <span class="string">"deleteLeft"</span>,
                    <span class="string">"modaledit.enterInsert"</span>
                ],
</code></pre>
<p>The rather cryptic key range captures all visible non-alphanumeric ASCII
characters. The rest of the command is exactly same as in the previous example.
The only difference is that we store the character to be searched into both
<code>from</code> and <code>to</code> arguments.</p>
<p>Now we can add the commands that change text inside braces, such as
<key>c</key><key>i</key><key>{</key> or <key>c</key><key>a</key><key>]</key>.</p>

<pre class="syntaxhighlight"><code>                <span class="string">"(,)"</span>: [
                    {
                        <span class="string">"command"</span>: <span class="string">"modaledit.selectBetween"</span>,
                        <span class="string">"args"</span>: <span class="string">"{ from: '(', to: ')', inclusive: __keys[1] == 'a' }"</span>
                    },
                    <span class="string">"deleteLeft"</span>,
                    <span class="string">"modaledit.enterInsert"</span>
                ],
                <span class="string">"{,}"</span>: [
                    {
                        <span class="string">"command"</span>: <span class="string">"modaledit.selectBetween"</span>,
                        <span class="string">"args"</span>: <span class="string">"{ from: '{', to: '}', inclusive: __keys[1] == 'a' }"</span>
                    },
                    <span class="string">"deleteLeft"</span>,
                    <span class="string">"modaledit.enterInsert"</span>
                ],
                <span class="string">"[,]"</span>: [
                    {
                        <span class="string">"command"</span>: <span class="string">"modaledit.selectBetween"</span>,
                        <span class="string">"args"</span>: <span class="string">"{ from: '[', to: ']', inclusive: __keys[1] == 'a' }"</span>
                    },
                    <span class="string">"deleteLeft"</span>,
                    <span class="string">"modaledit.enterInsert"</span>
                ],
                <span class="string">"&lt;,&gt;"</span>: [
                    {
                        <span class="string">"command"</span>: <span class="string">"modaledit.selectBetween"</span>,
                        <span class="string">"args"</span>: <span class="string">"{ from: '&lt;', to: '&gt;', inclusive: __keys[1] == 'a' }"</span>
                    },
                    <span class="string">"deleteLeft"</span>,
                    <span class="string">"modaledit.enterInsert"</span>
                ],
</code></pre>
<p>It is also useful to be able to change the current word the cursor is on. You
can do this by typing <key>c</key><key>i</key><key>w</key> (preserves separators)
or <key>c</key><key>a</key><key>w</key>. We use regular expressions as the
delimiters in this case. The <code>\W</code> regular expression matches all
non-alphanumeric characters (except underscore). Note the double escaping
needed to enter the <code>\</code> character. There are other commands we could use to
implement the operation, but this version works reliably in all scenarios.</p>

<pre class="syntaxhighlight"><code>                <span class="string">"w"</span>: [
                    {
                        <span class="string">"command"</span>: <span class="string">"modaledit.selectBetween"</span>,
                        <span class="string">"args"</span>: <span class="string">"{ from: '\\\\W', to: '\\\\W', regex: true, inclusive: __keys[1] == 'a' }"</span>
                    },
                    <span class="string">"deleteLeft"</span>,
                    <span class="string">"modaledit.enterInsert"</span>
                ]
            }
        },
</code></pre>
<blockquote>
<p>We could also implement delete commands <key>d</key><key>i</key><key>w</key>,
<key>d</key><key>t</key><key>-</key>, etc. in the similar fashion. But for the
sake of keeping the tutorial short, we'll leave those as an exercise.</p>
</blockquote>
<p>A shorthand for  <key>c</key><key>$</key> command is <key>C</key>.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"C"</span>: [
            <span class="string">"deleteAllRight"</span>,
            <span class="string">"modaledit.enterInsert"</span>
        ],
</code></pre>
<p><em>Substitution</em> commands do  basically same things as change commands;
<key>s</key> changes the character under cursor, and <key>S</key> is same as
<key>c</key><key>c</key>.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"s"</span>: [
            <span class="string">"deleteRight"</span>,
            <span class="string">"modaledit.enterInsert"</span>
        ],
        <span class="string">"S"</span>: [
            <span class="string">"deleteAllLeft"</span>,
            <span class="string">"deleteAllRight"</span>,
            <span class="string">"modaledit.enterInsert"</span>
        ],
</code></pre>
<h3 id="undo-amp-redo">Undo &amp; Redo</h3>
<p>You can undo the last change with <key>u</key>. We also clear the selection to
copy Vim's operation.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"u"</span>: [
            <span class="string">"undo"</span>,
            <span class="string">"modaledit.cancelSelection"</span>
        ],
</code></pre>
<p>Since redo is mapped to <key>Ctrl</key>+<key>r</key> by default, we leave this
binding as an exercise to the reader.</p>
<h2 id="visual-selection-commands">Visual (Selection) Commands</h2>
<p>Visual commands operate on the selected text. <key>&lt;</key> and <key>&gt;</key>
shift selected text left or right (indent/outdent).</p>

<pre class="syntaxhighlight"><code>        <span class="string">"&lt;"</span>: <span class="string">"editor.action.outdentLines"</span>,
        <span class="string">"&gt;"</span>: <span class="string">"editor.action.indentLines"</span>,
</code></pre>
<h3 id="clipboard-commands">Clipboard Commands</h3>
<p><key>y</key> yanks, i.e. copies, selected text to clipboard. Following Vim
convention, we also clear the selection.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"y"</span>: [
            <span class="string">"editor.action.clipboardCopyAction"</span>,
            <span class="string">"modaledit.cancelSelection"</span>
        ],
</code></pre>
<p><key>d</key> deletes (cuts) the selected text and puts it to clipboard. Capital
<key>D</key> deletes the rest of the line. <key>x</key> deletes just the
character under the cursor.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"d"</span>: <span class="string">"editor.action.clipboardCutAction"</span>,
        <span class="string">"D"</span>: [
            <span class="string">"cursorEndSelect"</span>,
            <span class="string">"editor.action.clipboardCutAction"</span>
        ],
        <span class="string">"x"</span>: [
            <span class="string">"cursorRightSelect"</span>,
            <span class="string">"editor.action.clipboardCutAction"</span>
        ],
</code></pre>
<blockquote>
<p><strong>Note</strong>: If there is no text selected, <key>y</key> and <key>d</key> commands
perform exactly the same actions as <key>y</key><key>y</key> and
<key>d</key><key>d</key> in Vim. That is, they yank or delete the current
line. Again, one of the subtle differences that is futile to try to unify.</p>
</blockquote>
<p>For pasting (or <em>putting</em> in Vim parlance) the text in clipboard you have two
commands: <key>p</key> puts the text after the cursor, and <key>P</key> puts it
before.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"p"</span>: [
            <span class="string">"cursorRight"</span>,
            <span class="string">"editor.action.clipboardPasteAction"</span>
        ],
        <span class="string">"P"</span>: <span class="string">"editor.action.clipboardPasteAction"</span>,
</code></pre>
<h3 id="switching-case">Switching Case</h3>
<p>Switching selected text to upper or lower case is done with a nifty trick.
We can examine the selection in a conditional command that calls different VS
Code commands based on the expression. The command is bound to the tilde
<key>~</key> character.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"~"</span>: {
            <span class="string">"condition"</span>: <span class="string">"__selection == __selection.toUpperCase()"</span>,
            <span class="string">"true"</span>: <span class="string">"editor.action.transformToLowercase"</span>,
            <span class="string">"false"</span>: <span class="string">"editor.action.transformToUppercase"</span>
        },
</code></pre>
<h2 id="marks">Marks</h2>
<p>Marks or bookmarks, as they are more commonly known, provide a handy way to
jump quickly inside documents. Surprisingly, VS Code does not contain this
feature out-of-the-box. Since it is easy to implement, ModalKeys fills the gap
and adds two simple commands: <code>modaledit.defineBookmark</code> and
<code>modaledit.goToBookmark</code>. Using these we can implement Vim's mark commands.</p>
<p>We can support dozens of bookmarks with one mapping using a character range.
To define a bookmark, you type <key>m</key><key>a</key>, for example, and to
jump to that mark, type <key>`</key><key>a</key>.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"m"</span>: {
            <span class="string">"a-z"</span>: {
                <span class="string">"command"</span>: <span class="string">"modaledit.defineBookmark"</span>,
                <span class="string">"args"</span>: <span class="string">"{ bookmark: __keys[1] }"</span>
            }
        },
        <span class="string">"`"</span>: {
            <span class="string">"a-z"</span>: {
                <span class="string">"command"</span>: <span class="string">"modaledit.goToBookmark"</span>,
                <span class="string">"args"</span>: <span class="string">"{ bookmark: __keys[1] }"</span>
            }
        },
</code></pre>
<h2 id="searching">Searching</h2>
<p>The last category of commands we implement is searching. We use the incremental
search command provided by ModalKeys for this. As in Vim, typing <key>/</key>
starts an incremental search. <key>?</key> starts a search backwards.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"/"</span>: {
            <span class="string">"command"</span>: <span class="string">"modaledit.search"</span>,
            <span class="string">"args"</span>: {
                <span class="string">"caseSensitive"</span>: <span class="literal">true</span>
            }
        },
        <span class="string">"?"</span>: {
            <span class="string">"command"</span>: <span class="string">"modaledit.search"</span>,
            <span class="string">"args"</span>: {
                <span class="string">"caseSensitive"</span>: <span class="literal">true</span>,
                <span class="string">"backwards"</span>: <span class="literal">true</span>
            }
        },
</code></pre>
<p>Jumping to next previous match is done with keys <key>n</key> and <key>N</key>.</p>

<pre class="syntaxhighlight"><code>        <span class="string">"n"</span>: <span class="string">"modaledit.nextMatch"</span>,
        <span class="string">"N"</span>: <span class="string">"modaledit.previousMatch"</span>,
</code></pre>
<p>There are some subtle differences in the search functionality as well. Instead
of just highlighting matches ModalKeys selects them. This is preferable
anyway, as replacing needs to be done manually with selection commands. Finally,
<code>modaledit.search</code> does not support regexes. Use VS Code's built-in find
command, if you need regex support.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We have built far from complete but nevertheless usable Vim emulation which
you can tweak in various ways to make it better. The point of this exercise was
to show that you can significantly enhance VS Code's editing experience using
just a simple extension and built-in commands.</p>
<p>When writing ModalKeys my goal was not to provide a new Vim emulation. In fact,
I don't use Vim-style key bindings myself. I find the countless keyboard
combinations in Vim superfuous and inconsistent. I doubt that anybody knows, let
alone <em>uses</em> all the available commands. Using Vim is like working in a
workshop where you have shelves full of bench planes but the only tool you
really need is your trusty No 4 Stanley.</p>
<p><img src="../images/wood-planes.jpg" alt="WTF?"></p>
<p>What I am trying to demonstrate is that you don't need to learn all the magical
Vim facilities to become better at editing. Just keep an eye on what operations
you repeat, and think how you could make them more efficient. Then add commands
that will speed up those operations. Try to make the new commands as general as
possible, and as easy as possible to use. Your text editor should adapt to your
way of working, not the other way around.</p>
<p>The thing that Vim got right, though, is modal editing. It is the laser beam
on the great white shark's head that really makes it cool. Modal editing puts
all the commands at your fingertips, and makes you faster. That is why Vim is
still popular, even though there is lot of competition around. So, the obvious
conclusion is to equip modern editors like VS Code with the same frickin'
laser beam. It requires some training to operate, but when properly configured
will cut through text at the speed of light.</p>
<p>Happy Editing! ð¦ð</p>


    </div>
            <div class="stickypane">

    <div class="pagemenu">
        <h3>On This Page</h3>
            <ul class="pagetree">

            </ul>
    </div>

            </div>
        </div>
    </div>
    <script src="js/main.js"></script>

</body>
</html>
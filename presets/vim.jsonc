/**
# Semi-complete Vim Keybindings for ModalEdit 

![](../images/pooh.jpg =375x403)
From get-go, providing full Vim emulation was a non-goal of ModalEdit. The idea 
of the extension is to provide an engine that allows the user to map any key 
combination to any command provided by VS Code. However, most users equate modal 
editing with Vim, and are familiar with its default keybindings. Vim users 
really love the powerful key sequences that combine editing operations with 
cursor motions or text ranges.

ModalEdit has also evolved by taking inspiration mainly from Vim. Many 
capabilities were added with the motive to enable some Vim feature that was 
previously not possible to implement. With version 2.0 ModalEdit's functionality 
is now extensive enough to build a semi-complete Vim emulation. So, here we go...

Adding Vim keybindings as optional presets serves two purposes: it lowers the
barrier of entry for Vim users who don't want to spend the time defining 
bindings from ground up. Secondly, Vim presets serve as an example to show
how you can build sophisticated command sequences using the machinery provided 
by ModalEdit. 

If you are not interested how the Vim keybindings are implemented and just want
to use them, you can skip this discussion. Just import the presets by pressing 
<key>Ctrl</key><key>Shift</key><key>P</key> and running command **ModalEdit: 
Import preset keybindings**. You will be presented a choice to import either
Vim bindings or any presets that you have created yourself. If you are planning 
to customize the bindings, or create Vim-style commands from scratch, this 
document gives you pointers how to go about doing so.

## Game Plan

We start with basic motion commands which are mostly straightforward to 
implement. Motions have two modes of operation: normal mode (moving cursor), and 
visual mode (extending selection). We make sure all motions work correctly in 
both modes. This allows us to reuse these keybindings when implementing more 
advanced operations. Our goal is to avoid repetition by building complex 
sequences from primitive commands.

In Vim, there are multiple key sequences for a same operation. For example,
you can convert a paragraph upper case by typing 
<key>g</key><key>U</key><key>i</key><key>p</key>. You can perform the same 
operation using visual mode by typing <key>v</key><key>i</key><key>p</key><key>U</key>. 
The trick we use is to convert key sequences that operate on character, word, 
line, paragraph, etc. to analagous key sequences that use visual mode. We can 
implement all the editing commands just to work on active selection and reuse 
these commands with the other key combinations. Consequently, the command 
definition then becomes a string mapping problem. And since we can use 
JavaScript to expressions to do string manipulation, these mappings are easy to 
formulate.

![](../images/vim-uppercase.gif)

Many ways to skin a cat...

## Motion Commands in Normal Mode

The list of available cursor motion commands is shown below.

| Keys      | Cursor Motion
| --------- | -------------------
| `Enter`   | Beginning of next line
| `Space`   | Next character on right
| `h`       | Left
| `j`       | Down
| `k`       | Up
| `l`       | Right
| `0`       | First character on line
| `$`       | Last character on line
| `^`       | First non-blank character on line
| `g_`      | Last non-blank character on line
| `gg`      | First charater in file
| `G`       | Last character in file
| `w`       | Beginning of next word
| `e`       | End of next word
| `b`       | Beginning of previous word
| `W`       | Beginning of next alphanumeric word
| `B`       | Beginning of previous alphanumeric word
| `H`       | Top of the screen
| `M`       | Middle of the screen
| `L`       | Bottom of the screen
| `%`       | Matching bracket

Now, lets implement all the keybindings listed above.
*/
{
    "keybindings": {
        /**
Cursor can be advanced in a file with with enter and space. These are not 
technically motion commands but included for compatibility. 
*/
        "\n": [
            "cursorDown",
            {
                "command": "cursorMove",
                "args": {
                    "to": "wrappedLineFirstNonWhitespaceCharacter"
                }
            }
        ],
        " ": "cursorRight",
        /**
Move cursor up/down/left/right.
*/
        "h": "cursorLeft",
        "j": "cursorDown",
        "k": "cursorUp",
        "l": "cursorRight",
        /**
Move to first/last character on line. These work also in visual mode.
*/
        "0": {
            "command": "cursorMove",
            "args": "{ to: 'wrappedLineStart', select: __selecting }"
        },
        "$": {
            "command": "cursorMove",
            "args": "{ to: 'wrappedLineEnd', select: __selecting }"
        },
        /**
Move to first/last non-blank character on line. Also these ones use the 
`__selecting` flag to check whether we are in visual mode.
*/
        "^": {
            "command": "cursorMove",
            "args": "{ to: 'wrappedLineFirstNonWhitespaceCharacter', select: __selecting }"
        },
        "g": {
            "_": {
                "command": "cursorMove",
                "args": "{ to: 'wrappedLineLastNonWhitespaceCharacter', select: __selecting }"
            },
            /**
Moving to the beginning of file is defined as a conditional command to make
it work in visual mode.
*/
            "g": {
                "condition": "__selecting",
                "true": "cursorTopSelect",
                "false": "cursorTop"
            },
            /**
## Other Commands Starting with <key>g</key>

Commands starting with <key>g</key> key are bit inconsistent in Vim. Some of 
them are basic motion commands, such as <key>g</key><key>_</key> and 
<key>g</key><key>g</key>, some are editing commands like <key>g</key><key>J</key>
and <key>g</key><key>U</key>, and some switch between tabs ü§∑‚Äç‚ôÇÔ∏è. Since we have to 
define all bindings with the same prefix in same place, we take a detour and add 
these commands before continuing with rest of the motion commands.

The commands we define are.

| Keys              | Command
| ----------------- | --------------------------------------
| `gJ`              | Join lines without space in between
| `gu`<_motion_>    | Convert text specified by <_motion_> to lowercase
| `gU`<_motion_>    | Convert text specified by <_motion_> to uppercase 
| `gt`              | Go to next tab
| `gT`              | Go to previous tab

Joining lines without space is done by deleting a character after the join 
command.
*/
            "J": [
                "editor.action.joinLines",
                "deleteRight"
            ],
            /**
The lower/uppercase transition works with any motion, but since we have not
defined all of them yet, we explain the command structure later in the document. 
The structure we use here is exactly the same as with <key>d</key> command, for 
example.
*/
            "u,U": {
                "id": 1,
                "help": "Change case with motion",
                "u,U": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: __cmd.slice(0, -3) + 'V' + __rcmd[0] }"
                },
                "h,j,k,l,w,e,b,W,B,%": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __cmd.slice(0, -3) + __rcmd[0] + __rcmd[1] }"
                },
                "^,$,0,G,H,M,L": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __rcmd[0] + __rcmd[1] }"
                },
                "g": {
                    "g,_": {
                        "command": "modaledit.typeNormalKeys",
                        "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                    }
                },
                "f,t,F,T": {
                    "help": "Do until _",
                    " -~": {
                        "command": "modaledit.typeNormalKeys",
                        "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                    }
                },
                "a,i": {
                    "help": "Do around/inside _",
                    "w,p,b,B,t, -/,:-@,[-`,{-~": {
                        "command": "modaledit.typeNormalKeys",
                        "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                    }
                },
                "`,'": {
                    "help": "Do until mark _",
                    "a-z": {
                        "command": "modaledit.typeNormalKeys",
                        "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                    }
                }
            },
            /**
These command switch to next/previous tab.
*/
            "t": "workbench.action.nextEditor",
            "T": "workbench.action.previousEditor"
        },
        /**
## Rest of the Motion Commands

Now we can complete the list of basic motion commands. This one movest the 
cursor at the end of the file and selects the range, if visual mode is on.
*/
        "G": {
            "condition": "__selecting",
            "true": "cursorBottomSelect",
            "false": "cursorBottom"
        },
        /**
The logic of separating words is bit different in VS Code and Vim, so we will
not try to imitate Vim behavior here. These keys are mapped to the most similar
motion available. The <key>W</key> and <key>B</key> commands skip separator
characters, and move to the start of the next/previous alphanumeric word. 
*/
        "w": "cursorWordStartRight",
        "e": "cursorWordEndRight",
        "b": "cursorWordStartLeft",
        "W": {
            "command": "cursorWordStartRight",
            "repeat": "__char.match(/\\W/)"
        },
        "B": {
            "command": "cursorWordStartLeft",
            "repeat": "__char.match(/\\W/)"
        },
        /**
Moving cursor to the top, middle, and bottom of the screen is mapped to 
<key>H</key> (high), <key>M</key> (middle), and <key>L</key> (low) keys. These 
mappings also work in visual mode.
*/
        "H": {
            "command": "cursorMove",
            "args": "{ to: 'viewPortTop', select: __selecting }"
        },
        "M": {
            "command": "cursorMove",
            "args": "{ to: 'viewPortCenter', select: __selecting }"
        },
        "L": {
            "command": "cursorMove",
            "args": "{ to: 'viewPortBottom', select: __selecting }"
        },
        /**
Move to matching bracket command is somewhat challenging to implement 
consistently in VS Code. This is due to the problem that there are no commands 
that do exactly what Vim's motions do. In normal mode we call the 
`jumpToBracket` command which works if the cursor is on top of a bracket, but
does not allow for the selection to be extended. In visual mode we use the
`smartSelect.expand` command instead to extend the selection to whatever 
syntactic scope is above the current selection. In many cases, it is more useful
motion than jumping to a matching bracket, but using it means that we are
diverging from Vim's functionality.
*/
        "%": {
            "condition": "__selecting",
            "true": "editor.action.smartSelect.expand",
            "false": "editor.action.jumpToBracket"
        },
        /**
## Jump to a Character

More advanced cursor motions in Vim include jump to character, which is really 
powerful when used with editing commands. With them we can apply edits upto or 
including a specified character. The same motions work also as jump commands in 
normal mode. We have to provide separate implementations for normal and visual 
mode, since we need to provide different parameters to the `modaledit.search` 
command that we utilizing.

We define these commands.

| Keys          | Cursor Motion
| ------------- | ---------------------------------------------
| `f`<_char_>   | Jump to next occurrence of <_char_> 
| `F`<_char_>   | Jump to previous occurrence of <_char_>
| `t`<_char_>   | Jump to character before the next occurrence of <_char_>
| `T`<_char_>   | Jump to character after the previous occurrence of <_char_>
| `;`           | Repeat previous f, t, F or T motion
| `,`           | Repeat previous f, t, F or T motion in opposite direction

All of these keybindings are implemented using the 
[incremental search](../README.html#incremental-search) command, just the
parameters are different for each case. Basically we just perform either a 
forward or backward search and adjust the cursor position after the character
has been selected. We also need to adjust cursor position before repeating the
search.

The adjustment is done by invoking key bindings <key>h</key> (left) or 
<key>l</key> (right), or sometimes by clearing the selection with <key>v</key>
key.
*/
        "f": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "typeAfterAccept": "h",
                "typeBeforeNextMatch": "l",
                "typeAfterNextMatch": "h",
                "typeAfterPreviousMatch": "v"
            }
        },
        "F": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "backwards": true,
                "typeAfterAccept": "v",
                "typeAfterNextMatch": "v",
                "typeBeforePreviousMatch": "l",
                "typeAfterPreviousMatch": "h"
            }
        },
        "t": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "typeAfterAccept": "hhv",
                "typeBeforeNextMatch": "ll",
                "typeAfterNextMatch": "hhv",
                "typeBeforePreviousMatch": "h",
                "typeAfterPreviousMatch": "lv"
            }
        },
        "T": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "backwards": true,
                "typeAfterAccept": "lv",
                "typeBeforeNextMatch": "h",
                "typeAfterNextMatch": "lv",
                "typeBeforePreviousMatch": "ll",
                "typeAfterPreviousMatch": "hhv"
            }
        },
        /**
Repeating the motions can be done simply by calling `nextMatch` or 
`previousMatch`.
*/
        ";": "modaledit.nextMatch",
        ",": "modaledit.previousMatch",
        /**
## Bookmarks

You can also combine jump to bookmark motions with editing commands in Vim.
Therefore, we define them along with the other motions. We use the 
[bookmark commands](../README.html#bookmarks) provided by ModalEdit to implement
these keybindings:

| Keys              | Cursor Motion
| ----------------- | -----------------------------------------------
| `m`<_char_>       | Define a bookmark and bind it to key <_char_>
| `` ` ``<_char_>   | Jump to bookmark bound to key <_char_>
| `'`<_char_>       | Jump to the first non-blank character of the line where bookmark <_char_> resides

Jump commands also work in visual mode.
*/
        "m": {
            "help": "Define mark _",
            "a-z": {
                "command": "modaledit.defineBookmark",
                "args": "{ bookmark: __rcmd[0] }"
            }
        },
        "`": {
            "a-z": {
                "command": "modaledit.goToBookmark",
                "args": "{ bookmark: __rcmd[0], select: __selecting }"
            }
        },
        "'": {
            "a-z": [
                {
                    "command": "modaledit.goToBookmark",
                    "args": "{ bookmark: __rcmd[0], select: __selecting }"
                },
                {
                    "command": "cursorMove",
                    "args": "{ to: 'wrappedLineFirstNonWhitespaceCharacter', select: __selecting }"
                }
            ]
        },
        /**
## Switching between Modes

Next, we define keybindings that switch between normal, insert, and visual mode:

| Keys      | Command
| --------- | --------------------------------
| `i`       | Switch to insert mode
| `I`       | Move to start of line and switch to insert mode
| `a`       | Move to next character and switch to insert mode
| `A`       | Move to end of line and switch to insert mode
| `o`       | Insert line below current line, move on it, and switch to insert mode
| `O`       | Insert line above current line, move on it, and switch to insert mode
| `v`       | Switch to visual mode
| `V`       | Select current line and switch to visual mode

These commands have more memorable names such as `i` = insert, `a` = append,
and `o` = open, but above we describe what the commands do exactly instead
of using these names.
*/
        "i": "modaledit.enterInsert",
        "I": [
            "cursorHome",
            "modaledit.enterInsert"
        ],
        /**
The `a` has to check if the cursor is at the end of line. If so, we don't move 
right because that would move to next line.
*/
        "a": [
            {
                "condition": "__char == ''",
                "false": "cursorRight"
            },
            "modaledit.enterInsert"
        ],
        "A": [
            "cursorEnd",
            "modaledit.enterInsert"
        ],
        "o": [
            "editor.action.insertLineAfter",
            "modaledit.enterInsert"
        ],
        "O": [
            "editor.action.insertLineBefore",
            "modaledit.enterInsert"
        ],
        /**
Note that visual mode is not really a mode. Basically we just set the
`__selecting` flag that changes the behavior of normal mode commands. Nor is
there a separate line selection mode. We just mimic Vim's behavior using 
VS Code's builtin commands that select ranges of text, when the `__selecting`
flag is on.
*/
        "v": "modaledit.toggleSelection",
        "V": [
            {
                "command": "cursorMove",
                "args": {
                    "to": "wrappedLineStart"
                }
            },
            "modaledit.toggleSelection",
            "cursorDownSelect"
        ],
        /**
## Editing in Normal Mode

Editing commands in normal mode typically either affect current character or
line, or expect a motion key sequence at the end which specifies the scope of
 the edit. Let's first define simple commands that do not require a motion
 annex:

| Keys  | Command
| ----- | -------------------------
| `x`   | Delete a character under cursor
| `X`   | Delete a character left of cursor (backspace)
| `r`   | Replace character under cursor (delete and switch to insert mode)
| `s`   | Substitute character under cursor (same as `r`)
| `S`   | Substitute current line (delete and switch to insert mode)
| `D`   | Delete rest of line
| `C`   | Change rest of line (delete and switch to insert mode)
| `Y`   | Yank (copy) rest of line
| `p`   | Paste contents of clipboard after cursor
| `P`   | Paste contents of clipboard at cursor
| `J`   | Join current and next line. Add space in between 
| `u`   | Undo last change
| `.`   | Repeat last change

<key>x</key> and <key>X</key> commands do exactly what <key>Delete</key> and
<key>Backspace</key> keys do.
*/
        "x": "deleteRight",
        "X": "deleteLeft",
        /**
<key>r</key> and <key>s</key> commands delete character under cursor and enter
insert mode. In Vim <key>r</key> and <key>R</key> keys swith momentarily or 
permanently to overwrite mode. Since this mode does not exist in VS Code, we
settle on mapping both keys to the same sequence. 
*/
        "r,s": [
            "deleteRight",
            "modaledit.enterInsert"
        ],
        /**
<key>S</key> substitutes the whole line. We don't need to implement the command
here as we can reuse the <key>c</key><key>c</key> command that we define later.
*/
        "S": {
            "command": "modaledit.typeNormalKeys",
            "args": {
                "keys": "cc"
            }
        },
        /**
Deleting in Vim always copies the deleted text into clipboard, so we do that
as well. If you are wondering why we don't use VS Code's cut command, it has a
synchronization issue that sometimes causes the execution to advance to the
next command in the sequence before cutting is done. This leads to strange
random behavior that usually causes the whole line to disappear instead of the
rest of line. 
*/
        "D": [
            "modaledit.cancelSelection",
            "cursorEndSelect",
            "editor.action.clipboardCopyAction",
            "deleteRight",
            "modaledit.cancelSelection"
        ],
        /**
Again, we utilize existing mappings to implement the <key>C</key> command. It
does same thing as keys <key>D</key><key>i</key> together.
*/
        "C": {
            "command": "modaledit.typeNormalKeys",
            "args": {
                "keys": "Di"
            }
        },
        /**
Yanking or copying is always done on selected range. So, we make sure that only
rest of line is selected before copying the range to clipboard. Afterwards we
clear the selection again.
*/
        "Y": [
            "modaledit.cancelSelection",
            "cursorEndSelect",
            "editor.action.clipboardCopyAction",
            "modaledit.cancelSelection"
        ],
        /**
Pasting text at cursor is done with <key>P</key> key. Following Vim convention 
<key>p</key> pastes text after cursor position. In both cases we clear the
selection after paste, so that we don't accidently end up in visual mode.
*/
        "p": [
            "cursorRight",
            "editor.action.clipboardPasteAction",
            "modaledit.cancelSelection"
        ],
        "P": [
            "editor.action.clipboardPasteAction",
            "modaledit.cancelSelection"
        ],
        /**
<key>J</key> joins current and next lines together adding a space in between.
There is a built in command that does just this.
*/
        "J": "editor.action.joinLines",
        /**
Undoing last change is also a matter of calling built-in command. We clear the
selection afterwards.
*/
        "u": [
            "undo",
            "modaledit.cancelSelection"
        ],
        /**
The last "simple" keybinding we define is <key>`</key> that repeats the last
command that changed the text somehow. This command is provided by ModalEdit. It
checks after each key sequence is typed whether it caused a change in file.
If so, it stores the seqeuence as a change. The command just runs the stored
keysequence again.
*/
        ".": "modaledit.repeatLastChange",
        /**
## Editing with Motions

So, far we have kept the structure of keybindings quite simple. Now we tackle
the types of keybinding that work in tandem with motion commands. Examples of
such commands include:

<key>c</key><key>i</key><key>b</key> - Change text inside curly braces `{}`

<key>></key><key>G</key> - Indent rest of the file

<key>y</key><key>\`</key><key>a</key> - Yank text from cursor position to mark `a`

We can combine any editing command with any motion, which gives us thousands
of possible combinations. First type the command key and then motion which
specifies the position or range you want to apply the command to.

| Keys          | Command
| ------------- | ---------------------------
| `d`<_motion_> | Delete range specified by <_motion_>
| `c`<_motion_> | Delete range specified by <_motion_> and switch to insert mode
| `y`<_motion_> | Yank range specified by <_motion_> to clipboard
| `>`<_motion_> | Indent range specified by <_motion_>
| `<`<_motion_> | Outdent range specified by <_motion_>
| `=`<_motion_> | Reindent (reformat) range specified by <_motion_>

We can define all commands listed above in a single keybinding block. Remember
that our strategy is just to map the key sequences of the edit commands that use 
motions to equivalent commands that work in visual mode. We do the specified 
motion in visual mode selecting a range of text, and then running the command 
on the selection. It does not matter which editing command we run, all of them 
can be mapped the same way.
*/
        "d,y,c,<,>,=": {
            "id": 2,
            "help": "Edit with motion",
            /**
The motions can be also divided to two categories: repeatable and non-repeatable.
Some motions we can repeat, such as move to next character/word/line, but some
we can only do once, such as move to end of line, beginning of file, or to a 
bookmark. Later on we make it possible to run repeatable motions _n_ times by
typing number _n_ before a motion command or an editing command. 

We can run all editing commands on the current line by repeating the command 
key. For example <key>y</key><key>y</key> yanks current line, and 
<key><</key><key><</key> outdents current line. By prefixing these commands 
with a number, we repeat the command _n_ times. To extract the number _n_ we
slice all but last 2 characters of the key sequence. Then we append `V` command
to it and lastly the actual editing command. The whole logic resides in the JS
expression in the `args` property below.

If you are wondering where the number prefix comes from as we don't have any
numbers in the path to our keybinding block, notice that we defined an `id` for
our block above. We can use this `id` to jump to the block from other keybinding
blocks. The entered key sequence `__cmd` contains the full sequence entered by
the user, not just immediate sequence that lead to the block. So, we can extract
the number from the start of the `__cmd` string.
*/
            "d,y,c,<,>,=": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: __cmd.slice(0, -2) + 'V' + (__rcmd[0] =='c' ? 'dO' : __rcmd[0]) }"
            },
            /**
Another thing to note is that we actually have some logic when choosing what
command to run; we transform the <key>c</key> key to <key>d</key><key>O</key>
sequence, which deletes the selected range and then inserts a new line above
cursor. As an example command <key>2</key><key>c</key><key>c</key> actually 
maps to command <key>2</key><key>V</key><key>d</key><key>O</key>. 

All the other repeatable commands can be defined in almost identical way. For
example the command to yank three words <key>3</key><key>y</key><key>w</key> is 
converted to a sequence <key>v</key><key>3</key><key>w</key><key>y</key>.
*/
            "h,j,k,l,w,e,b,W,B,%": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: 'v' + __cmd.slice(0, -2) + __rcmd[0] + __rcmd[1] }"
            },
            /**
Non-repeatable motions are even easier. We just basically rearrange the key
sequence and add <key>v</key> key in front.
*/
            "^,$,0,G,H,M,L": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: 'v' + __rcmd[0] + __rcmd[1] }"
            },
            "g": {
                "g,_": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                }
            },
            /**
Next motions jump to a character. They are handy when you want to edit text 
until a specified character. For example the command 
<key>d</key><key>t</key><key>"</key> deletes text until the next quotation mark. 
The implementation is exactly same as above, so the command would map to key
sequence <key>v</key><key>t</key><key>"</key><key>d</key>.
*/
            "f,t,F,T": {
                "help": "Do until _",
                " -~": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                }
            },
            /**
Doing an edit inside set of delimiters like braces, parenthesis or quotation
marks can be done with the <key>a</key> or <key>i</key> movement. The difference
between them is that <key>a</key> includes the delimiters in the edit whereas
<key>i</key> does not. The desired delimiter is the last key in the sequence.
Special delimiters <key>w</key>, <key>p</key>, <key>b</key>, <key>B</key>, and 
<key>t</key> apply the edit inside word, paragraph, parenthesis, curly braces,
and angle brackets respectively.
*/
            "a,i": {
                "help": "Do around/inside _",
                "w,p,b,B,t, -/,:-@,[-`,{-~": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                }
            },
            /**
The last motion you can combine with editing commands is jump to tag. It is
convenient when you want to edit long ranges of text that can't fit on screen.
We have two variants of the motion: <key>`</key> edits until the exact mark
location, <key>'</key> until the beginning of line where the mark specified as
the last key resides. Key sequence is rearranged exactly as above. 
*/
            "`,'": {
                "help": "Do until mark _",
                "a-z": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                }
            }
        },
        /**
## Repeating Commands

As stated above, you can repeat many motions and edit commands by prefixing
them with number(s). All of the repeatable commands are mapped below. The trick
is to define a [recursive keymap](../README.html#defining-recursive-keymaps)
that sticks in the same mapping while you type number keys. After you type the
actual command we either just invoke the command as many times as you typed, or
jump to either of the edit command keymaps defined above.

The recursive part is defined below.
*/
        "1-9": {
            "id": 3,
            "help": "Repeat n times",
            "0-9": 3,
            /**
If any of the repeatable motions is typed after a number, we just do that motion
_n_ times. The `parseInt` function extracts the number from the beginning of the
key sequence.
*/
            "h,j,k,l,w,b,W,B,u,%": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: __rcmd[0] }",
                "repeat": "parseInt(__cmd)"
            },
            /**
We can repeat <key>v</key> and <key>V</key> commands too. They will select _n_
characters or lines.
*/
            "v": {
                "command": "cursorRightSelect",
                "repeat": "parseInt(__cmd)"
            },
            "V": {
                "command": "expandLineSelection",
                "repeat": "parseInt(__cmd)"
            },
            /**
Also substitution commands can be repeated. In this case we just remap the
key sequence and insert the repetition count in it.
*/
            "s": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: parseInt(__cmd) + 'vc' }"
            },
            "S": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: parseInt(__cmd) + 'cc' }"
            },
            /**
We can join multiple lines at once too. This works because the 
`editor.action.joinLines` joins all selected lines. We just have to clear the
selection afterwards.
*/
            "J": [
                {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: parseInt(__cmd) + 'VJ' }"
                },
                "modaledit.cancelSelection"
            ],
            // Two ways of jumping to a line <_NUM_>`G` or <_NUM_>`gg`
            "g": {
                "g": [
                    {
                        "command": "revealLine",
                        "args": "{ lineNumber: parseInt(__cmd) - 1, at: 'top' }"
                    },
                    {
                        "command": "cursorMove",
                        "args": {
                            "to": "viewPortTop"
                        }
                    }
                ],
                // Repeat some `g` commands.
                "u,U": 1,
                "J": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: __cmd.slice(-2) }",
                    "repeat": "parseInt(__cmd)"
                }
            },
            "G": [
                {
                    "command": "revealLine",
                    "args": "{ lineNumber: parseInt(__cmd) - 1, at: 'top' }"
                },
                {
                    "command": "cursorMove",
                    "args": {
                        "to": "viewPortTop"
                    }
                }
            ],
            "d,c,y,<,>,=": 2
        },
        // Center cursor on screen
        "z": {
            "z": {
                "command": "revealLine",
                "args": "{ lineNumber: __line, at: 'center' }"
            }
        },
        // Entering command mode and closing documents
        ":": "workbench.action.showCommands",
        "Z": {
            "help": "Z - Close and save, Q - Close without saving",
            "Z": [
                "workbench.action.files.save",
                "workbench.action.closeActiveEditor"
            ],
            "Q": "workbench.action.closeActiveEditor"
        },
        // Searching
        "/": [
            {
                "command": "modaledit.search",
                "args": {
                    "caseSensitive": true,
                    "wrapAround": true
                }
            }
        ],
        "?": {
            "command": "modaledit.search",
            "args": {
                "backwards": true,
                "caseSensitive": true
            }
        },
        "n": "modaledit.nextMatch",
        "N": "modaledit.previousMatch"
    },
    // Select (visual) mode commands.
    "selectbindings": {
        "l": "cursorRightSelect",
        "h": "cursorLeftSelect",
        "j": "cursorDownSelect",
        "k": "cursorUpSelect",
        "w": "cursorWordStartRightSelect",
        "e": "cursorWordEndRightSelect",
        "b": "cursorWordStartLeftSelect",
        "W": {
            "command": "cursorWordStartRightSelect",
            "repeat": "__char.match(/\\W/)"
        },
        "B": {
            "command": "cursorWordStartLeftSelect",
            "repeat": "__char.match(/\\W/)"
        },
        // Select forwards/backwards until a character is found
        "f": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "selectTillMatch": true
            }
        },
        "F": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "backwards": true,
                "selectTillMatch": true
            }
        },
        "t": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "typeAfterAccept": "h",
                "typeBeforeNextMatch": "l",
                "typeAfterNextMatch": "h",
                "typeBeforePreviousMatch": "h",
                "typeAfterPreviousMatch": "l",
                "selectTillMatch": true
            }
        },
        "T": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "backwards": true,
                "typeAfterAccept": "l",
                "typeBeforeNextMatch": "h",
                "typeAfterNextMatch": "l",
                "typeBeforePreviousMatch": "l",
                "typeAfterPreviousMatch": "h",
                "selectTillMatch": true
            }
        },
        // Select around/inside
        "a,i": {
            "help": "Select around/inside _",
            "w": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '\\\\W', to: '\\\\W', regex: true, inclusive: __rcmd[1] == 'a' }"
                }
            ],
            "p": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '(?<=\\\\r?\\\\n)\\\\s*\\\\r?\\\\n', to: '(?<=\\\\r?\\\\n)\\\\s*\\\\r?\\\\n', regex: true, inclusive: __rcmd[1] == 'a', docScope: true }"
                }
            ],
            " -/,:-@,[-`,{-~": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: __rcmd[0], to: __rcmd[0], inclusive: __rcmd[1] == 'a' }"
                }
            ],
            "(,),b": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '(', to: ')', inclusive: __rcmd[1] == 'a', docScope: true }"
                }
            ],
            "{,},B": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '{', to: '}', inclusive: __rcmd[1] == 'a', docScope: true }"
                }
            ],
            "[,]": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '[', to: ']', inclusive: __rcmd[1] == 'a', docScope: true }"
                }
            ],
            "<,>,t": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '<', to: '>', inclusive: __rcmd[1] == 'a' }"
                }
            ]
        },
        // Indent/outdent/reformat selection
        ">": [
            "editor.action.indentLines",
            "modaledit.cancelSelection"
        ],
        "<": [
            "editor.action.outdentLines",
            "modaledit.cancelSelection"
        ],
        "=": [
            "editor.action.formatSelection",
            "modaledit.cancelSelection"
        ],
        // Delete (cut) selection
        "d,x": [
            "editor.action.clipboardCopyAction",
            "deleteRight",
            "modaledit.cancelSelection"
        ],
        // Change selection
        "c": [
            "editor.action.clipboardCopyAction",
            "deleteRight",
            "modaledit.enterInsert"
        ],
        // Yank (copy) selection
        "y": [
            "editor.action.clipboardCopyAction",
            "modaledit.cancelSelection"
        ],
        // Transform selection to lower/uppercase
        "u": [
            "editor.action.transformToLowercase",
            "modaledit.cancelSelection"
        ],
        "U": [
            "editor.action.transformToUppercase",
            "modaledit.cancelSelection"
        ]
    }
}
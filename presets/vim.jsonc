/**
# Semi-complete Vim Keybindings for ModalEdit 

![](../images/pooh.jpg =375x403)
From get-go, providing full Vim emulation was a non-goal of ModalEdit. The idea 
of the extension is to provide an engine that allows the user to map any key 
combination to any command provided by VS Code. However, most users equate modal 
editing with Vim, and are familiar with its default keybindings. Vim users 
really love the powerful key sequences that combine editing operations with 
cursor motions or text ranges.

ModalEdit has also evolved by taking inspiration mainly from Vim. Many 
capabilities were added with the motive to enable some Vim feature that was 
previously not possible to implement. With version 2.0 ModalEdit's functionality 
is now extensive enough to build a semi-complete Vim emulation. So, here we go...

Adding Vim keybindings as optional presets serves two purposes: it lowers the
barrier of entry for Vim users who don't want to spend the time defining 
bindings from ground up. Secondly, Vim presets serve as an example to show
how you can build sophisticated command sequences using the machinery provided 
by ModalEdit. 

If you are not interested how the Vim keybindings are implemented and just want
to use them, you can skip this discussion. Just import the presets by pressing 
<key>Ctrl</key><key>Shift</key><key>P</key> and running command **ModalEdit: 
Import preset keybindings**. You will be presented a choice to import either
Vim bindings or any presets that you have created yourself. If you are planning 
to customize the bindings, or create Vim-style commands from scratch, this 
document gives you pointers how to go about doing so.

## Game Plan

We start with basic motion commands which are mostly straightforward to 
implement. Motions have two modes of operation: normal mode (moving cursor), and 
visual mode (extending selection). We make sure all motions work correctly in 
both modes. This allows us to reuse these keybindings when implementing more 
advanced operations. Our goal is to avoid repetition by building complex 
sequences from primitive commands.

In Vim, there are multiple key sequences for a same operation. For example,
you can convert a paragraph upper case by typing 
<key>g</key><key>U</key><key>i</key><key>p</key>. You can perform the same 
operation using visual mode by typing <key>v</key><key>i</key><key>p</key><key>U</key>. 
The trick we use is to convert key sequences that operate on character, word, 
line, paragraph, etc. to analagous key sequences that use visual mode. We can 
implement all the editing commands just to work on active selection and reuse 
these commands with the other key combinations. Consequently, the command 
definition then becomes a string mapping problem. And since we can use 
JavaScript to expressions to do string manipulation, these mappings are easy to 
formulate.

![](../images/vim-uppercase.gif)

Many ways to skin a cat...

## Motion Commands in Normal Mode

The list of available cursor motion commands is shown below.

| Keys      | Cursor Motion
| --------- | -------------------
| `Enter`   | Beginning of next line
| `Space`   | Next character on right
| `h`       | Left
| `j`       | Down
| `k`       | Up
| `l`       | Right
| `0`       | First character on line
| `$`       | Last character on line
| `^`       | First non-blank character on line
| `g_`      | Last non-blank character on line
| `gg`      | First charater in file
| `G`       | Last character in file
| `w`       | Beginning of next word
| `W`       | Next word separator on right
| `b`       | Beginning of previous word
| `B`       | Previous word separator on left
| `H`       | Top of the screen
| `M`       | Middle of the screen
| `L`       | Bottom of the screen
| `%`       | Matching bracket

Now, lets implement all the keybindings listed above.
*/
{
    "keybindings": {
        /**
Cursor can be advanced in a file with with enter and space. These are not 
technically motion commands but included for compatibility. 
*/
        "\n": [
            "cursorDown",
            {
                "command": "cursorMove",
                "args": {
                    "to": "wrappedLineFirstNonWhitespaceCharacter"
                }
            }
        ],
        " ": "cursorRight",
        /**
Move cursor up/down/left/right.
*/
        "h": "cursorLeft",
        "j": "cursorDown",
        "k": "cursorUp",
        "l": "cursorRight",
        /**
Move to first/last character on line. These work also in visual mode.
*/
        "0": {
            "command": "cursorMove",
            "args": "{ to: 'wrappedLineStart', select: __selecting }"
        },
        "$": {
            "command": "cursorMove",
            "args": "{ to: 'wrappedLineEnd', select: __selecting }"
        },
        /**
Move to first/last non-blank character on line. Also these ones use the 
`__selecting` flag to indicate whether we are in visual mode.
*/
        "^": {
            "command": "cursorMove",
            "args": "{ to: 'wrappedLineFirstNonWhitespaceCharacter', select: __selecting }"
        },
        "g": {
            "_": {
                "command": "cursorMove",
                "args": "{ to: 'wrappedLineLastNonWhitespaceCharacter', select: __selecting }"
            },
            /**
Moving to the beginning of file is defined as a conditional command to make
it work in visual mode.
*/
            "g": {
                "condition": "__selecting",
                "true": "cursorTopSelect",
                "false": "cursorTop"
            },
            /**
## Other Commands Starting with <key>g</key>

Commands starting with <key>g</key> key are bit inconsistent in Vim. Some of 
them are basic motion commands, such as <key>g</key><key>_</key> and 
<key>g</key><key>g</key>, some are editing commands like <key>g</key><key>J</key>
and <key>g</key><key>U</key>, and some switch between tabs ü§∑‚Äç‚ôÇÔ∏è. Since we have to 
define all bindings with the same prefix in same place, we take a detour and add 
these commands before continuing with rest of the motion commands.

The commands we define are.

| Keys              | Command
| ----------------- | --------------------------------------
| `gJ`              | Join lines without space in between
| `gu`<_motion_>    | Convert text specified by <_motion_> to lowercase
| `gU`<_motion_>    | Convert text specified by <_motion_> to uppercase 
| `gt`              | Go to next tab
| `gT`              | Go to previous tab

Joining lines without space is done by deleting a character after the join 
command.
*/
            "J": [
                "editor.action.joinLines",
                "deleteRight"
            ],
            /**
The lower/uppercase transition works with any motion, but since we have not
defined all of them yet, we explain the command structure later in the document. 
The structure we use here is exactly the same as with <key>d</key> command, for 
example.
*/
            "u,U": {
                "id": 1,
                "help": "Change case with motion",
                "u,U": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: __cmd.slice(0, -3) + 'V' + __rcmd[0] }"
                },
                "h,j,k,l,w,b,W,B,%": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __cmd.slice(0, -3) + __rcmd[0] + __rcmd[1] }"
                },
                "^,$,0,G,H,M,L": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __rcmd[0] + __rcmd[1] }"
                },
                "g": {
                    "g,_": {
                        "command": "modaledit.typeNormalKeys",
                        "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                    }
                },
                "f,t,F,T": {
                    "help": "Do until _",
                    " -~": {
                        "command": "modaledit.typeNormalKeys",
                        "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                    }
                },
                "a,i": {
                    "help": "Do around/inside _",
                    "w,p,b,B,t, -/,:-@,[-`,{-~": {
                        "command": "modaledit.typeNormalKeys",
                        "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                    }
                },
                "`,'": {
                    "help": "Do until bookmark _",
                    "a-z": {
                        "command": "modaledit.typeNormalKeys",
                        "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                    }
                }
            },
            /**
These command switch to next/previous tab.
*/
            "t": "workbench.action.nextEditor",
            "T": "workbench.action.previousEditor"
        },
        /**
## Rest of the Motion Commands

Now we can complete the list of basic motion commands. This one movest the 
cursor at the end of the file and selects the range, if visual mode is on.
*/
        "G": {
            "condition": "__selecting",
            "true": "cursorBottomSelect",
            "false": "cursorBottom"
        },
        /**
The logic of separating words is bit different in VS Code and Vim, so we will
not try to imitate Vim behavior here. In general, <key>W</key> will jump further 
forwards than <key>w</key>, and <key>B</key> further backwards than <key>b</key>, 
but they will not necessarily stop at the same character as in Vim.
*/
        "w": "cursorWordStartRight",
        "W": "cursorWordEndRight",
        "b": "cursorWordStartLeft",
        "B": "cursorWordEndLeft",
        /**
Moving cursor to the top, middle, and bottom of the screen is mapped to 
<key>H</key> (high), <key>M</key> (middle), and <key>L</key> (low) keys. These 
mappings also work in visual mode.
*/
        "H": {
            "command": "cursorMove",
            "args": "{ to: 'viewPortTop', select: __selecting }"
        },
        "M": {
            "command": "cursorMove",
            "args": "{ to: 'viewPortCenter', select: __selecting }"
        },
        "L": {
            "command": "cursorMove",
            "args": "{ to: 'viewPortBottom', select: __selecting }"
        },
        /**
Move to matching bracket command is somewhat challenging to implement 
consistently in VS Code. This is due to the problem that there are no commands 
that do exactly what Vim's motions do. In normal mode we call the 
`jumpToBracket` command which works if the cursor is on top of a bracket, but
does not allow for the selection to be extended. In visual mode we use the
`smartSelect.expand` command instead to extend the selection to whatever 
syntactic scope is above the current selection. In many cases, it is more useful
motion than jumping to a matching bracket, but using it means that we are
diverging from Vim's functionality.
*/
        "%": {
            "condition": "__selecting",
            "true": "editor.action.smartSelect.expand",
            "false": "editor.action.jumpToBracket"
        },
        /**
## Jump to a Character

More advanced cursor motions in Vim include jump to character, which is really 
powerful when used with editing commands. With them you can apply edits upto or 
including a specified character. The same motions work also as jump commands in 
normal mode. We have to provide separate implementations for normal and visual 
mode, since we need to provide different parameters to the `modaledit.search` 
command that we utilizing.

We define these commands.

| Keys          | Cursor Motion
| ------------- | ---------------------------------------------
| `f`<_char_>   | Jump to next occurrence of <_char_> 
| `F`<_char_>   | Jump to previous occurrence of <_char_>
| `t`<_char_>   | Jump to character before the next occurrence of <_char_>
| `T`<_char_>   | Jump to character after the previous occurrence of <_char_>
| `;`           | Repeat previous f, t, F or T motion
| `,`           | Repeat previous f, t, F or T motion in opposite direction

All of these keybindings are implemented using the 
[incremental search](../README.html#incremental-search) command, just the
parameters are different for each case. Basically we just perform either a 
forward or backward search and adjust the cursor position after the character
has been selected. We also need to adjust cursor position before repeating the
search.

The adjustment is done by invoking key bindings <key>h</key> (left) or 
<key>l</key> (right), or sometimes by clearing the selection with <key>v</key>
key.
*/
        "f": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "typeAfterAccept": "h",
                "typeBeforeNextMatch": "l",
                "typeAfterNextMatch": "h",
                "typeAfterPreviousMatch": "v"
            }
        },
        "F": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "backwards": true,
                "typeAfterAccept": "v",
                "typeAfterNextMatch": "v",
                "typeBeforePreviousMatch": "l",
                "typeAfterPreviousMatch": "h"
            }
        },
        "t": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "typeAfterAccept": "hhv",
                "typeBeforeNextMatch": "ll",
                "typeAfterNextMatch": "hhv",
                "typeBeforePreviousMatch": "h",
                "typeAfterPreviousMatch": "lv"
            }
        },
        "T": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "backwards": true,
                "typeAfterAccept": "lv",
                "typeBeforeNextMatch": "h",
                "typeAfterNextMatch": "lv",
                "typeBeforePreviousMatch": "ll",
                "typeAfterPreviousMatch": "hhv"
            }
        },
        /**
Repeating the motions can be done simply by calling `nextMatch` or 
`previousMatch`.
*/
        ";": "modaledit.nextMatch",
        ",": "modaledit.previousMatch",
        /**
## Bookmarks

You can also combine jump to bookmark motions with editing commands in Vim.
Therefore, we define them along with the other motions. We use the 
[bookmark commands](../README.html#bookmarks) provided by ModalEdit to implement
these keybindings:

| Key               | Cursor Motion
| ----------------- | -----------------------------------------------
| `m`<_char_>       | Define a bookmark and bind it to key <_char_>
| `` ` ``<_char_>   | Jump to bookmark bound to key <_char_>
| `'`<_char_>       | Jump to the first non-blank character of the line where bookmark <_char_> resides

Jump commands also work in visual mode.
*/
        "m": {
            "help": "Define mark _",
            "a-z": {
                "command": "modaledit.defineBookmark",
                "args": "{ bookmark: __rcmd[0] }"
            }
        },
        "`": {
            "a-z": {
                "command": "modaledit.goToBookmark",
                "args": "{ bookmark: __rcmd[0], select: __selecting }"
            }
        },
        "'": {
            "a-z": [
                {
                    "command": "modaledit.goToBookmark",
                    "args": "{ bookmark: __rcmd[0], select: __selecting }"
                },
                {
                    "command": "cursorMove",
                    "args": "{ to: 'wrappedLineFirstNonWhitespaceCharacter', select: __selecting }"
                }
            ]
        },
        // Switch to insert mode
        "i": "modaledit.enterInsert",
        "I": [
            "cursorHome",
            "modaledit.enterInsert"
        ],
        // Append text
        "a": [
            {
                "condition": "__char == ''",
                "false": "cursorRight"
            },
            "modaledit.enterInsert"
        ],
        "A": [
            "cursorEnd",
            "modaledit.enterInsert"
        ],
        // Append at the end of the word
        "e": {
            "a": [
                "cursorWordEndRight",
                "modaledit.enterInsert"
            ]
        },
        // Open new line
        "o": [
            "editor.action.insertLineAfter",
            "modaledit.enterInsert"
        ],
        "O": [
            "editor.action.insertLineBefore",
            "modaledit.enterInsert"
        ],
        // Editing
        // Replace a character under cursor
        "r": [
            "deleteRight",
            "modaledit.enterInsert"
        ],
        // Join lines
        "J": "editor.action.joinLines",
        // Undo
        "u": [
            "undo",
            "modaledit.cancelSelection"
        ],
        // Repeat last change
        ".": "modaledit.repeatLastChange",
        // Selection mode on/off
        "v": "modaledit.toggleSelection",
        "V": [
            {
                "command": "cursorMove",
                "args": {
                    "to": "wrappedLineStart"
                }
            },
            "modaledit.toggleSelection",
            "cursorDownSelect"
        ],
        // Edit (delete/yank/change/indent/outdent/reformat) with motion
        "d,y,c,<,>,=": {
            "id": 2,
            "help": "Edit with motion",
            // Motions possibly repeated <_NUM_> times
            "d,y,c,<,>,=": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: __cmd.slice(0, -2) + 'V' + (__rcmd[0] =='c' ? 'dO' : __rcmd[0]) }"
            },
            "h,j,k,l,w,b,W,B,%": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: 'v' + __cmd.slice(0, -2) + __rcmd[0] + __rcmd[1] }"
            },
            // Non-repeatable motions
            "^,$,0,G,H,M,L": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: 'v' + __rcmd[0] + __rcmd[1] }"
            },
            "g": {
                "g,_": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                }
            },
            // Apply until character is found
            "f,t,F,T": {
                "help": "Do until _",
                " -~": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                }
            },
            // Apply inside delimiters
            "a,i": {
                "help": "Do around/inside _",
                "w,p,b,B,t, -/,:-@,[-`,{-~": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                }
            },
            // Apply until bookmark
            "`,'": {
                "help": "Do until bookmark _",
                "a-z": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: 'v' + __rcmd[1] + __rcmd[0] + __rcmd[2] }"
                }
            }
        },
        // Delete rest of line
        "D": [
            "modaledit.cancelSelection",
            "cursorEndSelect",
            "editor.action.clipboardCopyAction",
            "deleteRight",
            "modaledit.cancelSelection"
        ],
        // Delete single character
        "x": "deleteRight",
        // Yank rest of line
        "Y": [
            "modaledit.cancelSelection",
            "cursorEndSelect",
            "editor.action.clipboardCopyAction",
            "modaledit.cancelSelection"
        ],
        // Change rest of line
        "C": {
            "command": "modaledit.typeNormalKeys",
            "args": {
                "keys": "Di"
            }
        },
        // Substitute character (selection)
        "s": [
            "deleteRight",
            "modaledit.enterInsert"
        ],
        "S": {
            "command": "modaledit.typeNormalKeys",
            "args": {
                "keys": "cc"
            }
        },
        // Paste commands
        "p": [
            "cursorRight",
            "editor.action.clipboardPasteAction",
            "modaledit.cancelSelection"
        ],
        "P": [
            "editor.action.clipboardPasteAction",
            "modaledit.cancelSelection"
        ],
        // Repeat commands by prefixing with number(s)
        "1-9": {
            "id": 3,
            "help": "Repeat n times",
            "0-9": 3,
            "h,j,k,l,w,b,W,B,u,%": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: __rcmd[0] }",
                "repeat": "parseInt(__cmd)"
            },
            "v": {
                "command": "cursorRightSelect",
                "repeat": "parseInt(__cmd)"
            },
            "V": {
                "command": "expandLineSelection",
                "repeat": "parseInt(__cmd)"
            },
            "s": [
                {
                    "command": "cursorRightSelect",
                    "repeat": "parseInt(__cmd)"
                },
                "deleteRight",
                "modaledit.enterInsert"
            ],
            "S": {
                "command": "modaledit.typeNormalKeys",
                "args": "{ keys: parseInt(__cmd) + 'cc' }"
            },
            "J": [
                {
                    "command": "expandLineSelection",
                    "repeat": "parseInt(__cmd)"
                },
                "editor.action.joinLines",
                "modaledit.cancelSelection"
            ],
            // Two ways of jumping to a line <_NUM_>`G` or <_NUM_>`gg`
            "g": {
                "g": [
                    {
                        "command": "revealLine",
                        "args": "{ lineNumber: parseInt(__cmd) - 1, at: 'top' }"
                    },
                    {
                        "command": "cursorMove",
                        "args": {
                            "to": "viewPortTop"
                        }
                    }
                ],
                // Repeat some `g` commands.
                "u,U": 1,
                "J": {
                    "command": "modaledit.typeNormalKeys",
                    "args": "{ keys: __cmd.slice(-2) }",
                    "repeat": "parseInt(__cmd)"
                }
            },
            "G": [
                {
                    "command": "revealLine",
                    "args": "{ lineNumber: parseInt(__cmd) - 1, at: 'top' }"
                },
                {
                    "command": "cursorMove",
                    "args": {
                        "to": "viewPortTop"
                    }
                }
            ],
            "d,c,y,<,>,=": 2
        },
        // Center cursor on screen
        "z": {
            "z": {
                "command": "revealLine",
                "args": "{ lineNumber: __line, at: 'center' }"
            }
        },
        // Entering command mode and closing documents
        ":": "workbench.action.showCommands",
        "Z": {
            "help": "Z - Close and save, Q - Close without saving",
            "Z": [
                "workbench.action.files.save",
                "workbench.action.closeActiveEditor"
            ],
            "Q": "workbench.action.closeActiveEditor"
        },
        // Searching
        "/": [
            {
                "command": "modaledit.search",
                "args": {
                    "caseSensitive": true,
                    "wrapAround": true
                }
            }
        ],
        "?": {
            "command": "modaledit.search",
            "args": {
                "backwards": true,
                "caseSensitive": true
            }
        },
        "n": "modaledit.nextMatch",
        "N": "modaledit.previousMatch"
    },
    // Select (visual) mode commands.
    "selectbindings": {
        "l": "cursorRightSelect",
        "h": "cursorLeftSelect",
        "j": "cursorDownSelect",
        "k": "cursorUpSelect",
        "w": "cursorWordStartRightSelect",
        "W": "cursorWordEndRightSelect",
        "b": "cursorWordStartLeftSelect",
        "B": "cursorWordEndLeftSelect",
        // Select forwards/backwards until a character is found
        "f": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "selectTillMatch": true
            }
        },
        "F": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "backwards": true,
                "selectTillMatch": true
            }
        },
        "t": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "typeAfterAccept": "h",
                "typeBeforeNextMatch": "l",
                "typeAfterNextMatch": "h",
                "typeBeforePreviousMatch": "h",
                "typeAfterPreviousMatch": "l",
                "selectTillMatch": true
            }
        },
        "T": {
            "command": "modaledit.search",
            "args": {
                "acceptAfter": 1,
                "backwards": true,
                "typeAfterAccept": "l",
                "typeBeforeNextMatch": "h",
                "typeAfterNextMatch": "l",
                "typeBeforePreviousMatch": "l",
                "typeAfterPreviousMatch": "h",
                "selectTillMatch": true
            }
        },
        // Select around/inside
        "a,i": {
            "help": "Select around/inside _",
            "w": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '\\\\W', to: '\\\\W', regex: true, inclusive: __rcmd[1] == 'a' }"
                }
            ],
            "p": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '(?<=\\\\r?\\\\n)\\\\s*\\\\r?\\\\n', to: '(?<=\\\\r?\\\\n)\\\\s*\\\\r?\\\\n', regex: true, inclusive: __rcmd[1] == 'a', docScope: true }"
                }
            ],
            " -/,:-@,[-`,{-~": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: __rcmd[0], to: __rcmd[0], inclusive: __rcmd[1] == 'a' }"
                }
            ],
            "(,),b": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '(', to: ')', inclusive: __rcmd[1] == 'a', docScope: true }"
                }
            ],
            "{,},B": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '{', to: '}', inclusive: __rcmd[1] == 'a', docScope: true }"
                }
            ],
            "[,]": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '[', to: ']', inclusive: __rcmd[1] == 'a', docScope: true }"
                }
            ],
            "<,>,t": [
                {
                    "command": "modaledit.selectBetween",
                    "args": "{ from: '<', to: '>', inclusive: __rcmd[1] == 'a' }"
                }
            ]
        },
        // Indent/outdent/reformat selection
        ">": [
            "editor.action.indentLines",
            "modaledit.cancelSelection"
        ],
        "<": [
            "editor.action.outdentLines",
            "modaledit.cancelSelection"
        ],
        "=": [
            "editor.action.formatSelection",
            "modaledit.cancelSelection"
        ],
        // Delete (cut) selection
        "d,x": [
            "editor.action.clipboardCopyAction",
            "deleteRight",
            "modaledit.cancelSelection"
        ],
        // Change selection
        "c": [
            "editor.action.clipboardCopyAction",
            "deleteRight",
            "modaledit.enterInsert"
        ],
        // Yank (copy) selection
        "y": [
            "editor.action.clipboardCopyAction",
            "modaledit.cancelSelection"
        ],
        // Transform selection to lower/uppercase
        "u": [
            "editor.action.transformToLowercase",
            "modaledit.cancelSelection"
        ],
        "U": [
            "editor.action.transformToUppercase",
            "modaledit.cancelSelection"
        ]
    }
}
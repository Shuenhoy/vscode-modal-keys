/**
# Build Your Own Vim Emulation for VS Code

![Shark](../images/sharks.png =256x206)
[Vim][] is the great white shark of text editors. It has survived among modern 
IDEs because of its unique philosophy. It uses [modal editing][] which is almost 
an opposite approach to how other editors work. You start in "normal" mode where
you can navigate and edit text, but not insert it. When you want to enter text, 
you switch to "insert" mode where you can type new text, but cannot do anything 
else. So, you end up bouncing between modes as you edit your text file.

This might sound difficult, and granted, the learning curve is steep. But after 
you are accustomed to this way of working, it is very difficult to go back. If
you are used to modal editing, for example having to use arrow keys to move 
cursor, feels uncomfortable. The proof of this is that nearly all popular
text editors have some kind of add-in that provides Vim emulation. VS Code has
several of them.

So, why write yet another extension that provides Vim emulation? Well, the
problem is that most emulators try to make VS Code behave exactly like Vim which
it obviously can't do. Trying to mimick Vim's functionality too closely 
results in unsatisfying user experience as it has a lot of features that do not 
map naturally to features of VS Code. 

Instead of copying Vim functionality as closely as possible we can utilize VS 
Code's existing features and just add the concept of modal editing to the mix. 
Turns out implementing modal editing is extremely simple. We basically provide 
pair of commands that switch between normal mode and insert mode.

To complete the Vim experience we need to be able to bind key sequences pressed
in normal mode to VS Code's commands. This we can do by defining the key 
bindings in the VS Codes standard configuration file `settings.json`. We provide 
a way to bind any key to any command, or sequence of commands. We can even 
provide conditional commands that do different things based on editor state. 
This is the core feature set that [ModalEdit][] provides. Refer to the 
[README][ModalEdit] page for the details of the configuration options.

With these capabilities we can start building our Vim emulation. We don't need
to use Vim's standard key bindings, if we don't want to. You can map any key
(sequence) to any command. But to keep things familiar, we'll follow Vim's
conventions for now to demonstrate that you can implement its functionality
reasonably closely.

> This document is actually a literate `settings.json` file which is super handy
> as I can test the key bindings right away while writing this document. Saving
> the file makes ModalEdit apply the bindings. The web page you are reading is 
> generated from the file using LiTScript. See [LiTScript home page][LiTScript], 
> if you want to learn more about that. 

So, let's start configuring our Vim emulator by adding the ModalEdit's 
configuration block for key binding.
*/
{
    "modaledit.keybindings": {
/**
## Switching Between Modes

First things first: we need to be able to enter the normal mode somehow. The
`Esc` key is mapped to the `modaledit.enterNormal` command by default, so we 
dont't need to do anything about that. If you like, you can map other keys to
this command using VS Code's standard keymappings pressing `Ctrl+K Ctrl+S`.

There are multiple ways to enter insert mode, though. If you want to insert text
in the current cursor position, you press `i`.
*/
        "i": "modaledit.enterInsert",
/**
To insert text at the beginning of line, you press `I`. For this operation, we
need a command sequence.
*/
        "I": [
            "cursorHome",
            "modaledit.enterInsert"
        ],
/**
_Appending_ text works analogously. `a` appends text after current character
and `A` at the end of the line. There is a special case, though. If cursor is 
already at the last character of the line, it should not move. This is why we
use a conditional command to move the cursor only, if the current character
is not `0`, which it is at the end of the line.
*/
        "a": [
            {
                "condition": "__char == 0",
                "false": "cursorRight"
            },
            "modaledit.enterInsert"
        ],
        "A": [
            "cursorEnd",
            "modaledit.enterInsert"
        ],
/**
The third way to enter insert mode is to _open_ a line. This means creating an
empty line, and putting the cursor on it. There are two variants of this command 
as well: `o` opens a new line below the current line whereas `O` opens it on the 
current line.
*/
        "o": [
            "editor.action.insertLineAfter",
            "modaledit.enterInsert"
        ],
        "O": [
            "editor.action.insertLineBefore",
            "modaledit.enterInsert"
        ],
    },
/**
Now we can test the commands we just created.

![mode switching](../images/mode-switching.gif)

## Cursor Movement
*/
    "files.exclude": {
        "out": false
    },
    "search.exclude": {
        "out": true
    },
    "typescript.tsc.autoDetect": "off",
}
/**
[Vim]: https://www.vim.org/
[ModalEdit]: ../README.html
[modal editing]: https://unix.stackexchange.com/questions/57705/modeless-vs-modal-editors
[LiTScript]: https://johtela.github.io/litscript/
*/